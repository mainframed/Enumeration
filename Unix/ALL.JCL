//OMVSENUM JOB (JOB),'JOB',CLASS=A,MSGCLASS=A,
//         NOTIFY=&SYSUID,REGION=0M
//*********************************************************************
//****
//**** DO NOT EDIT THIS FILE IT IS AUTO GENERATED BY THE ALL.SH SCRIPT
//****
//*********************************************************************
//*********************************************************************
//* Delete the files if they exist
//*********************************************************************
//REMOVE    EXEC PGM=BPXBATCH
//STDIN     DD DUMMY
//STDOUT    DD DUMMY
//STDERR    DD DUMMY     
//STDPARM   DD *
SH cd /u/mainframe;
 rm ENUM.rexx;
 rm OMVSEnum.sh;
 rm FileSystemTraversal.java;
 rm portscan.java;
//*********************************************************************
//PUTFILE  PROC FOLDER='/u/mainframe',FILENAME=''
//*********************************************************************
//**** Put the files in unix
//*********************************************************************
//PUTFILE  EXEC PGM=IEBGENER
//SYSPRINT DD SYSOUT=*
//SYSUT1   DD DUMMY
//SYSUT2   DD PATH='&FOLDER.&FILENAME',
//            PATHOPTS=(ORDWR,OCREAT), 
//            PATHDISP=(KEEP,DELETE),
//            PATHMODE=(SIRWXU,SIRGRP),            
//            FILEDATA=TEXT               
//SYSIN   DD  DUMMY
// PEND
//*********************************************************************
//PUTENUM EXEC PUTFILE,FILENAME='ENUM.rexx'
//PUTFILE.SYSUT1 DD DATA,DLM='@@'
/* REXX */

/*
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$7'`         `'!$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$$$$7'                  `$$$$$$$$$       $     Y$$   $   $$$   $    YP    $$
$$$$7'              $$$:.   :$$$$$$$$   $$$$$   L  ?$   $   $$$   $   s  s   $$
$$$'                 '7$'    `$$$$$$$      $$   $L  ?   $   $$$   $   $$$$   $$
$$          .4$$$a           :$$$$$$$   $$$$$   $$L     $   Y$P   $   $$$$   $$
$        .4$$$$$$$    $$    .$$$$$$$$       $   $$$L    $L       J$   $$$$   $$
:       :$$$$$$$$'   $$$$     ~'$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
!        '!:$$$7'                 '$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
                                   `+$$$$$$$$$$$P     Y$$$$$P       Y$$$$$$$$$$
.                                    l$$$$$$$$$$  Y$P  $$$$$   $$$   $$$$$$$$$$
::                                .4$$$$$$$$$$$$$$P  S$$$$$$   $$$   $$$$$$$$$$
$$a.             .$             .4$$$$$$$$$$$$$$P  l$$$$$$$$   Y$P   $$$$$$$$$$
$$$$b.          $$$$b.       .4$$$$$$$$$$$$$$$$$       $$  $L       J$$$$$$$$$$
$$$$$$$$A.   .4$$$$$$$A.   .4$$$$$$$$$$$$$$$$$$$$$$$$$$$$ss$$$$$$$$$$$$$$$$$$$$
$$$$$$$$$$$$$$$$$$$$$$$$$.$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$Y'                                                                       '?$$
$$                    z/OS Enumeration Pentesting Tool                       $$
$$                                                                           $$
$$   Arguments: HELP, ALL, APF, CAT, JOB, PATH, SEC, SVC, TSTA, TSOT,        $$
$$              USSU, VERS, WHO                                              $$
$$b.                                                                       .d$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$SoF!
*/

/*------------------------------------------------------------------*\
|* z/OS System Enumeration Tool                                     *|
|*                                                                  *|
|* Description: Enumerates z/OS system information for use in       *|
|*              penetration testing and security assessments.       *|
|*                                                                  *|
|* Arguments:                                                       *|
|*   ALL  - Display all information                                 *|
|*   APF  - APF authorized datasets                                 *|
|*   CAT  - Display master catalog                                  *|
|*   JOB  - Display executing job name                              *|
|*   PATH - Display dataset concatenations                          *|
|*   SEC  - Security manager information                            *|
|*   SVC  - Display SVC information                                 *|
|*   TSTA - Display TESTAUTH authorization                          *|
|*   TSOT - Display TSO AUTHCMD/AUTHPGM tables                      *|
|*   USSU - Display USS/OMVS user list                              *|
|*   VERS - Operating system version info                           *|
|*   WHO  - Currently logged on users (TSO/OMVS)                    *|
|*                                                                  *|
|* Credits: Mark Zelden (IPLINFO), CBT Tape Files 221/496,          *|
|*          Ayoub Elaassal, Jim Taylor, Davide Girardi              *|
\*------------------------------------------------------------------*/

NUMERIC DIGITS 20

/*==================================================================*/
/* EBCDIC-SAFE BRACKET/BRACE PLACEHOLDERS                          */
/*==================================================================*/
/* These placeholders work across all EBCDIC code pages.            */
/* After downloading output, use sed to replace with actual chars:  */
/*                                                                  */
/*   sed 's/<<LB>>/[/g; s/<<RB>>]/]/g; s/<<LC>>/{/g; s/<<RC>>}/}/g' */
/*                                                                  */
/* Or use any find/replace tool:                                    */
/*   <<LB>> -> [    (left square bracket)                           */
/*   <<RB>> -> ]    (right square bracket)                          */
/*   <<LC>> -> {    (left curly brace)                              */
/*   <<RC>> -> }    (right curly brace)                             */
/*==================================================================*/

/* Initialize global assessment variables */
assessMode = 0
findings.0 = 0
findingtemplate.0 = 0
verificationcaption.0 = 0
verificationsteps.0 = 0

/* Global variables for AddToArray */
globalVars = 'tsoUsers. tasks. tasksUsers. omvs. omvsUsers.',
  'jobs. jobsUsers. system.'

/* Global variables for findings */
findingsVars = 'assessMode findings. findingtemplate.',
  'verificationcaption. verificationsteps. ipAddress smfid VSTEP_DELIM'

/* Delimiter for verification steps */
VSTEP_DELIM = '|~~|'

ipAddress = ''
smfid = ''

/* Parse arguments and environment */
PARSE SOURCE s1 s2 prg s3 name s4 s5 space .
PARSE UPPER ARG type restArgs

/* Parse ASSESS subarguments if needed */
IF type == 'ASSESS' THEN DO
  PARSE VAR restArgs ipAddress
  /* Initialize assessment mode */
  assessMode = 1
  findings.0 = 0
  /* Get SMFID from system */
  smfid = GetLparName()
END

/* Adjust for ISPF environment */
IF space == 'ISPF' THEN DO
  SAY ''
  SAY ''
  SAY ''
END

/* Show banner for non-ASSESS modes */
IF type /== 'ASSESS' THEN CALL ShowBanner

/* Set program name based on environment */
IF prg /== '?' & space /== 'OMVS' THEN
  prgname = name||'('||prg||')'
ELSE
  prgname = name

/* Main dispatch logic */
SELECT
  WHEN type == 'APF'  THEN CALL EnumApf
  WHEN type == 'CAT'  THEN CALL EnumCatalog
  WHEN type == 'JOB'  THEN CALL EnumJobname
  WHEN type == 'PATH' THEN DO
    IF space /== 'OMVS' THEN CALL EnumPath
    ELSE SAY 'DDNAME not supported in OMVS'
  END
  WHEN type == 'SEC'  THEN CALL EnumSecurity
  WHEN type == 'SVC'  THEN CALL EnumSvc
  WHEN type == 'TSTA' THEN CALL EnumTestauth
  WHEN type == 'TSOT' THEN CALL EnumTsoTables
  WHEN type == 'USSU' THEN CALL EnumUssUsers
  WHEN type == 'VERS' THEN CALL EnumVersion
  WHEN type == 'WHO'  THEN CALL EnumUsers

  WHEN type == 'ALL'  THEN DO
    CALL PrintBanner 'z/OS System Enumeration'
    SAY 'Executing from:' prgname
    SAY ''
    CALL EnumVersion
    CALL EnumSecurity
    CALL EnumJobname
    CALL EnumUsers
    CALL EnumApf
    CALL EnumSvc
    CALL EnumTestauth
    CALL EnumUssUsers
    CALL EnumTsoTables
    IF space /== 'OMVS' THEN DO
      CALL EnumPath 1
    END
  END

  WHEN type == 'ASSESS' THEN DO
    /* Run all enumeration functions normally */
    CALL PrintSectionBanner 'z/OS System Enumeration (Assessment Mode)'
    SAY 'Executing from:' prgname
    SAY 'Target IP:' ipAddress
    SAY 'SMFID:' smfid
    SAY ''
    CALL EnumVersion
    CALL EnumSecurity
    CALL EnumJobname
    CALL EnumUsers
    CALL EnumApf
    CALL EnumSvc
    CALL EnumTestauth
    CALL EnumUssUsers
    CALL EnumTsoTables
    IF space /== 'OMVS' THEN DO
      CALL EnumPath 1
    END
    /* Output JSON assessment results at the end */
    CALL OutputAssessmentJSON
  END

  OTHERWISE DO
    CALL ShowUsage
    EXIT 8
  END
END

EXIT 0



/*------------------------------------------------------------------*/
/* Display usage information                                        */
/*------------------------------------------------------------------*/

ShowBanner: PROCEDURE
/* credit to https://16colo.rs/pack/sae-006/FMB-SKLL.ASC */
SAY "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"||,
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"
SAY "$$$$$$$$$$$7'`         `'!$$$$$$$$$$$$$"||,
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"
SAY "$$$$$$$7'                  `$$$$$$$$$  "||,
"     $     Y$$   $   $$$   $    YP    $$"
SAY "$$$$7'              $$$:.   :$$$$$$$$  "||,
" $$$$$   L  ?$   $   $$$   $   s  s   $$"
SAY "$$$'                 '7$'    `$$$$$$$  "||,
"    $$   $L  ?   $   $$$   $   $$$$   $$"
SAY "$$          .4$$$a           :$$$$$$$  "||,
" $$$$$   $$L     $   Y$P   $   $$$$   $$"
SAY "$        .4$$$$$$$    $$    .$$$$$$$$  "||,
"     $   $$$L    $L       J$   $$$$   $$"
SAY ":       :$$$$$$$$'   $$$$     ~'$$$$$$$"||,
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"
SAY "!        '!:$$$7'                 '$$$$"||,
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"
SAY "                                   `+$$"||,
"$$$$$$$$$P     Y$$$$$P       Y$$$$$$$$$$"
SAY ".                                    l$"||,
"$$$$$$$$$  Y$P  $$$$$   $$$   $$$$$$$$$$"
SAY "::                                .4$$$"||,
"$$$$$$$$$$$P  S$$$$$$   $$$   $$$$$$$$$$"
SAY "$$a.             .$             .4$$$$$"||,
"$$$$$$$$$P  l$$$$$$$$   Y$P   $$$$$$$$$$"
SAY "$$$$b.          $$$$b.       .4$$$$$$$$"||,
"$$$$$$$$$       $$  $L       J$$$$$$$$$$"
SAY "$$$$$$$$A.   .4$$$$$$$A.   .4$$$$$$$$$$"||,
"$$$$$$$$$$$$$$$$$$ss$$$$$$$$$$$$$$$$$$$$"
SAY "$$$$$$$$$$$$$$$$$$$$$$$$$.$$$$$$$$$$$$$"||,
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"
RETURN

ShowUsage: PROCEDURE

SAY "$$Y'                                   "||,
"                                    '?$$"
SAY "$$                    z/OS Enumeration "||,
"Pentesting Tool                       $$"
SAY "$$                                     "||,
"                                      $$"
SAY "$$   Arguments: HELP, ALL, APF, CAT, JO"||,
"B, PATH, SEC, SVC, TSTA, TSOT,        $$"
SAY "$$              USSU, VERS, WHO        "||,
"                                      $$"
SAY "$$b.                                   "||,
"                                    .d$$"
SAY "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$"||,
"$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$SoF!"
RETURN


ShowHelp: PROCEDURE EXPOSE prgname space
  SAY ''
  SAY 'z/OS Enumeration tool by Soldier of FORTRAN'
  SAY ''
  SAY 'Arguments:'
  SAY "  'HELP' - Display help information"
  SAY "  'ALL'  - Display all information"
  SAY "  'APF'  - Display APF authorized datasets"
  SAY "  'CAT'  - Display master catalog"
  SAY "  'JOB'  - Display executing job name"
  SAY "  'PATH' - Display dataset concatenations"
  SAY "  'SEC'  - Display security manager info"
  SAY "  'SVC'  - Display all SVCs"
  SAY "  'TSTA' - Display TESTAUTH authorization"
  SAY "  'TSOT' - Display TSO AUTHCMD/AUTHPGM tables"
  SAY "  'USSU' - Display USS/OMVS user list"
  SAY "  'VERS' - Display system version information"
  SAY "  'WHO'  - Display logged on TSO/OMVS users"
  SAY "  'ASSESS' - Print the findings"
  SAY ''
  SAY 'Example:'
  IF space /== 'OMVS' THEN SAY prgname "'WHO'"
  ELSE SAY prgname 'WHO'
RETURN

/*------------------------------------------------------------------*/
/* Enumerate executing job name                                     */
/*------------------------------------------------------------------*/
EnumJobname: PROCEDURE

  CALL PrintSectionBanner 'Job Information'
  cvt = GetPtr(16)
  tcbp = GetPtr(cvt)
  tcb = GetPtr(tcbp+4)
  tiot = GetPtr(tcb+12)
  jobname = STRIP(GetStorage(tiot, 8))
  SAY 'Executing Job Name:' jobname
RETURN

/*------------------------------------------------------------------*/
/* Enumerate logged on users (TSO/OMVS/Started Tasks/Jobs)         */
/*------------------------------------------------------------------*/
EnumUsers: PROCEDURE EXPOSE (globalvars)

  CALL PrintSectionBanner 'Logged On Users'
  cvt = GetPtr(16)
  asvt = GetPtr(cvt+556) + 512
  asvtMaxu = GetPtr(asvt+4)

  /* Initialize arrays */
  tsoUsers.0 = 0
  tasks.0 = 0
  tasksUsers.0 = 0
  omvs.0 = 0
  omvsUsers.0 = 0
  jobs.0 = 0
  jobsUsers.0 = 0
  system.0 = 0

  /* Iterate through address spaces */
  DO i = 0 TO asvtMaxu - 1
    ascb = GetStorage(asvt+16+(i*4), 4)

    /* Check if address space is in use */
    IF BITAND(ascb, '80000000'x) == '00000000'x THEN DO
      ascb = C2D(ascb)
      cscb = GetPtr(ascb+56)
      chtrkid = GetStorage(cscb+28, 1)
      ascbjbni = GetPtr(ascb+172)
      ascbjbns = GetPtr(ascb+176)
      asxb = GetPtr(ascb+108)
      ascboucb = GetPtr(ascb+144)
      oucbsubn = GetStorage(ascboucb+176, 4)
      oucbtrxn = GetStorage(ascboucb+200, 8)
      oucbusrd = GetStorage(ascboucb+208, 8)

      /* Started task */
      IF ascbjbns <> 0 & chtrkid == '02'x THEN DO
        usid = GetUserid(ascb)
        CALL AddToArray 'tasks', GetStorage(ascbjbns, 8)
        CALL AddToArray 'tasksUsers', usid
      END

      /* TSO user */
      IF ascbjbns <> 0 & chtrkid == '01'x THEN DO
        CALL AddToArray 'tsoUsers', GetStorage(ascbjbns, 8)
      END

      /* System */
      IF ascbjbns <> 0 & chtrkid == '04'x THEN DO
        CALL AddToArray 'system', GetStorage(ascbjbns, 8)
      END

      /* OMVS user */
      IF STRIP(oucbsubn) == 'OMVS' THEN DO
        CALL AddToArray 'omvs', oucbtrxn
        CALL AddToArray 'omvsUsers', oucbusrd
      END

      /* Batch job */
      IF ascbjbni <> 0 & chtrkid == '03'x THEN DO
        IF STRIP(oucbsubn) == 'OMVS' THEN ITERATE
        usid = GetUserid(ascb)
        CALL AddToArray 'jobs', GetStorage(ascbjbni, 8)
        CALL AddToArray 'jobsUsers', usid
      END
    END
  END

  /* Display results */
  SAY '**** Started Tasks - Owner ****'
  DO i = 1 TO tasks.0
    SAY tasks.i '-' tasksUsers.i
  END

  SAY ''
  SAY '**** TSO Users - Owner ****'
  DO i = 1 TO tsoUsers.0
    SAY tsoUsers.i '-' tsoUsers.i
  END

  SAY ''
  SAY '**** OMVS Users - Owner ****'
  DO i = 1 TO omvs.0
    SAY omvs.i '-' omvsUsers.i
  END

  SAY ''
  SAY '**** Jobs - Owner ****'
  DO i = 1 TO jobs.0
    SAY jobs.i '-' jobsUsers.i
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate security manager (RACF/ACF2/Top Secret)               */
/*------------------------------------------------------------------*/
EnumSecurity: PROCEDURE EXPOSE (findingsVars)

  CALL PrintSectionBanner 'Security Settings'

  IF assessMode == 0 THEN SAY 'External Security Manager:'
  ELSE SAY 'External Security Manager:'

  cvt = GetPtr(16)
  cvtrac = GetPtr(cvt+992)
  id = GetStorage(cvtrac, 4)

  SELECT
    WHEN id == 'RCVT' THEN CALL EnumRacf cvtrac
    WHEN id == 'RTSS' THEN CALL EnumTopSecret cvtrac
    OTHERWISE CALL EnumAcf2 cvt
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate RACF configuration                                     */
/*------------------------------------------------------------------*/
EnumRacf: PROCEDURE EXPOSE (findingsVars) warningDatasets,
  excessiveUaccDatasets excessiveAccessDatasets
  PARSE ARG rcvt

  racfVrm = GetStorage(rcvt+616, 4)
  rcvtDsdt = GetPtr(rcvt+224)
  dsdtNum = GetPtr(rcvtDsdt+4)
  dsdtPrim = STRIP(GetStorage(rcvtDsdt+177, 44), 'T')
  dsdtBack = STRIP(GetStorage(rcvtDsdt+353, 44), 'T')

  SAY 'Product: RACF'
  SAY 'Version: FMID HRF'racfVrm
  SAY 'Datasets:'
  SAY ''

  /* Always show access since we're on RACF */
  SAY 'UACC | WARN | ACCESS | DATASET'
  SAY '-----|------|--------|' || COPIES('-', 44)

  IF dsdtNum == 1 THEN DO
    /* Check access for primary and backup - READ access is a finding */
    /* Pass empty strings for volume/missing to get simple format */
    outputprim = CheckAndReportDatasetAccess(dsdtPrim, '', '', 1)
    SAY outputprim
    outputback = CheckAndReportDatasetAccess(dsdtBack, '', '', 1)
    SAY outputback
  END
  ELSE DO
    offset = 0
    DO i = 1 TO dsdtNum
      prim = STRIP(GetStorage(rcvtDsdt+177+offset, 44), 'T')
      back = STRIP(GetStorage(rcvtDsdt+353+offset, 44), 'T')
      offset = offset + 352
      /* Check access for primary and backup - READ access is a finding */
      /* Pass empty strings for volume/missing to get simple format */
      outputprim = CheckAndReportDatasetAccess(prim, '', '', 1)
      SAY outputprim
      outputback = CheckAndReportDatasetAccess(back, '', '', 1)
      SAY outputback
    END
  END

  /* Check if we need to add findings for RACF dataset security */
  /* Parse all fields from the output: UACC | WARN | ACCESS | DATASET */
  PARSE VAR outputprim primuacc '|' primwarn '|' primaccess '|' .
  PARSE VAR outputback backuacc '|' backwarn '|' backaccess '|' .
  primuacc = STRIP(primuacc)
  primwarn = STRIP(primwarn)
  primaccess = STRIP(primaccess)
  backuacc = STRIP(backuacc)
  backwarn = STRIP(backwarn)
  backaccess = STRIP(backaccess)

  IF assessMode == 1 THEN DO
    /* Check for user access to RACF datasets */
    IF primaccess \== 'NONE' | backaccess \== 'NONE' THEN DO
      CALL AddFinding 'RACF-DATASET-ACCESS'
      CALL AddVerificationCaption 'Run the REXX script ENUM with the',
        'SEC argument and observe that the testing account has READ or',
        'greater access to the RACF datasets.'
      CALL AddVerificationContent 'UACC | WARN | ACCESS | DATASET'||,
        ' -----|------|--------|---------------------------------'||,
        ' '||outputprim||' '||outputback
    END

    /* Check for excessive UACC on RACF datasets */
    IF primuacc \== 'NONE' | backuacc \== 'NONE' THEN DO
      CALL AddFinding 'RACF-DATASET-EXCESSIVE-UACC'
      CALL AddVerificationCaption 'Run the REXX script ENUM with the',
        'SEC argument and observe that the RACF datasets have a UACC',
        'of READ or greater.'
      CALL AddVerificationContent 'UACC | WARN | ACCESS | DATASET'||,
        ' -----|------|--------|---------------------------------'||,
        ' '||outputprim||' '||outputback
    END

    /* Check for WARNING mode on RACF datasets */
    IF primwarn == 'YES' | backwarn == 'YES' THEN DO
      CALL AddFinding 'RACF-DATASET-WARNING-MODE'
      CALL AddVerificationCaption 'Run the REXX script ENUM with the',
        'SEC argument and observe that the RACF datasets are configured',
        'with WARNING mode enabled.'
      CALL AddVerificationContent 'UACC | WARN | ACCESS | DATASET'||,
        ' -----|------|--------|---------------------------------'||,
        ' '||outputprim||' '||outputback
    END
  END

  SAY ''
  CALL EnumSetropts rcvt
RETURN

/*------------------------------------------------------------------*/
/* Enumerate Top Secret configuration                              */
/*------------------------------------------------------------------*/
EnumTopSecret: PROCEDURE EXPOSE (findingsVars) warningDatasets,
  excessiveUaccDatasets excessiveAccessDatasets
  PARSE ARG cvtrac

  rcvtDsn = STRIP(GetStorage(cvtrac+56, 44))
  SAY 'Product: Top Secret'
  SAY 'Dataset:' rcvtDsn
  SAY ''
  SAY 'Note: Access checking for Top Secret datasets requires'
  SAY '      Top Secret-specific commands (not yet implemented)'
RETURN

/*------------------------------------------------------------------*/
/* Enumerate ACF2 configuration                                     */
/*------------------------------------------------------------------*/
EnumAcf2: PROCEDURE EXPOSE (findingsVars) warningDatasets,
  excessiveUaccDatasets excessiveAccessDatasets
  PARSE ARG cvt

  cvtJesct = GetPtr(cvt+296)
  sscvt = GetPtr(cvtJesct+24)

  DO WHILE sscvt <> 0
    ssctsNam = GetStorage(sscvt+8, 4)

    IF ssctsNam == 'ACF2' THEN DO
      accvt = GetPtr(sscvt+20)
      accpfxp = GetPtr(accvt-4)
      accpidl = C2D(GetStorage(accpfxp+8, 2))
      lenId = accpidl - 4
      accpids = STRIP(GetStorage(accpfxp+12, lenId))
      acf2Dsns = GetPtr(accvt+252)
      acf2Dnum = C2D(GetStorage(acf2Dsns+16, 2))

      SAY 'Product: ACF2'
      SAY 'Version:' accpids
      SAY 'Dataset(s):'

      DO i = 1 TO acf2Dnum
        adsOff = acf2Dsns + 24 + ((i-1)*64)
        acf2Type = GetStorage(adsOff, 8)
        acf2Dsn = GetStorage(adsOff+16, 44)
        SAY ' ' acf2Type '-' acf2Dsn
      END

      SAY ''
      SAY 'Note: Access checking for ACF2 datasets requires'
      SAY '      ACF2-specific commands (not yet implemented)'

      LEAVE
    END

    sscvt = GetPtr(sscvt+4)
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate APF authorized libraries                              */
/*------------------------------------------------------------------*/
EnumApf: PROCEDURE EXPOSE space (findingsVars)

  CALL PrintSectionBanner 'APF Authorized Datasets/Libraries'

  IF space == 'OMVS' THEN DO
    SAY '! APF Dataset Checking Not Supported in UNIX'
    missing = '******'
    SAY ''
  END

  /* Check if we're on RACF to determine if we show access columns */
  cvt = GetPtr(16)
  cvtrac = GetPtr(cvt+992)
  id = GetStorage(cvtrac, 4)
  showAccess = (id == 'RCVT')

  /* Initialize finding tracking arrays */
  warningDatasets = ''
  excessiveUaccDatasets = ''
  excessiveAccessDatasets = ''

  IF showAccess THEN DO
    SAY 'VOLUME | EXISTS | UACC | WARN | ACCESS | DATASET'
    SAY '-------|--------|------|------|--------|' || COPIES('-', 20)
  END
  ELSE DO
    SAY 'VOLUME | EXISTS | DATASET'
    SAY '-------|--------|' || COPIES('-', 44)
  END

  cvtAuthl = GetPtr(cvt+484)

  /* Check if APF table is dynamic or static */
  IF cvtAuthl == C2D('7FFFF001'x) THEN DO
    CALL EnumDynamicApf cvt, showAccess
  END
  ELSE DO
    CALL EnumStaticApf cvtAuthl, showAccess
  END

  /* Add findings if any issues were found */
  IF showAccess & assessMode == 1 THEN DO
    IF warningDatasets \== '' THEN DO
      CALL AddFinding 'APF-WARNING-MODE-ENABLED'
      CALL AddVerificationCaption 'Run the REXX script ENUM and observe',
        'that the following datasets were configured with WARNING mode',
        'enabled:'
      CALL AddVerificationContent warningDatasets
    END

    IF excessiveUaccDatasets \== '' THEN DO
      CALL AddFinding 'APF-EXCESSIVE-UACC'
      CALL AddVerificationCaption 'Run the REXX script ENUM and observe',
        'that the following datasets were configured with a UACC of',
        'UPDATE, CONTROL, or ALTER:'
      CALL AddVerificationContent excessiveUaccDatasets
    END

    IF excessiveAccessDatasets \== '' THEN DO
      CALL AddFinding 'APF-EXCESSIVE-USER-ACCESS'
      CALL AddVerificationCaption 'Run the REXX script ENUM and observe',
        'that the testing account had UPDATE, CONTROL, or ALTER access',
        'to the following datasets:'
      CALL AddVerificationContent excessiveAccessDatasets
    END
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate dynamic APF table                                      */
/*------------------------------------------------------------------*/
EnumDynamicApf: PROCEDURE EXPOSE space warningDatasets,
  excessiveUaccDatasets excessiveAccessDatasets
  PARSE ARG cvt, showAccess

  cvtEcvt = GetPtr(cvt+140)
  ecvtCsvt = GetPtr(cvtEcvt+228)
  apfPtr = GetPtr(ecvtCsvt+12)
  cur = GetPtr(apfPtr+8)
  last = GetPtr(apfPtr+12)

  DO FOREVER
    dataset = GetStorage(cur+24, 44)
    missing = '  Yes '

    IF SUBSTR(dataset, 1, 1) \== '00'x THEN DO
      volSms = GetStorage(cur+4, 1)

      IF BITAND(volSms, '80'x) == '80'x THEN DO
        volume = 'SMS   '
        IF space /== 'OMVS' THEN
          retcode = LISTDSI("'"STRIP(dataset)"'" norecall)
      END
      ELSE DO
        volume = GetStorage(cur+68, 6)
        IF space /== 'OMVS' THEN
          retcode = LISTDSI("'"STRIP(dataset)"'",
            'volume('STRIP(volume)')' norecall)
      END

      IF retcode <> 0 THEN DO
        IF SYSREASON == 24 THEN missing = '  No  '
        ELSE missing = SPACE(D2C(SYSREASON), 8, ' ')
      END

      /* Check dataset access if on RACF */
      IF showAccess THEN DO
        output = CheckAndReportDatasetAccess(dataset, volume, missing)
        SAY output
      END
      ELSE DO
        SAY LEFT(STRIP(volume),6) '|' STRIP(LEFT(missing,6)),
           '|' STRIP(dataset)
      END
    END

    IF cur == last THEN LEAVE
    cur = GetPtr(cur+8)
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate static APF table                                       */
/*------------------------------------------------------------------*/
EnumStaticApf: PROCEDURE EXPOSE warningDatasets,
  excessiveUaccDatasets excessiveAccessDatasets
  PARSE ARG cvtAuthl, showAccess

  numApf = C2D(GetStorage(cvtAuthl, 2))
  len = C2D(GetStorage(cvtAuthl+2, 1))
  cur = cvtAuthl + 3

  DO i = 1 TO numApf
    volume = GetStorage(cur, 6)
    dataset = GetStorage(cur+7, len)
    missing = '  N/A  '

    /* Check dataset access if on RACF */
    IF showAccess THEN DO
      output = CheckAndReportDatasetAccess(dataset, volume, missing)
      SAY output
    END
    ELSE DO
      SAY STRIP(volume) '|' STRIP(dataset)
    END

    cur = cur + len + 1
    len = C2D(GetStorage(cur-1, 1))
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate operating system version information                  */
/*------------------------------------------------------------------*/
EnumVersion: PROCEDURE

  CALL PrintSectionBanner 'Operating System Version'

  cvt = GetPtr(16)
  cvtExt2 = GetPtr(cvt+328)
  cvtJesct = GetPtr(cvt+296)
  ecvt = GetPtr(cvt+140)

  /* OS version */
  prodName = GetStorage(cvt-40, 7)
  prodName2 = STRIP(GetStorage(ecvt+496, 16), 'T')
  ver = GetStorage(ecvt+512, 2)
  rel = GetStorage(ecvt+514, 2)
  mod = GetStorage(ecvt+516, 2)
  vrm = ver'.'rel'.'mod
  fmidNum = GetStorage(cvt-32, 7)

  SAY 'The OS version is' prodName2 vrm '- FMID' fmidNum,
    '('prodName').'

  /* LPAR and Processor information */
  csd = GetPtr(cvt+660)
  ecvtHdnm = GetStorage(ecvt+336, 8)  /* Hardware name */
  ecvtLpnm = GetStorage(ecvt+344, 8)  /* LPAR name */

  IF ecvtHdnm \== '        ' & ecvtLpnm \== '        ' THEN DO
    csdPlpn = C2D(GetStorage(csd+252, 1))  /* LPAR number */
    SAY 'The Processor name is' STRIP(ecvtHdnm)'.',
      'The LPAR SMFID is' STRIP(ecvtLpnm) '(LPAR #'csdPlpn').'
  END

  /* TSO version */
  cvtTvt = GetPtr(cvt+156)
  tsvtLver = GetStorage(cvtTvt+100, 1)
  tsvtLrel = GetStorage(cvtTvt+101, 2)
  tsvtLrel = FORMAT(tsvtLrel)
  tsvtLmod = GetStorage(cvtTvt+103, 1)
  tsoLev = tsvtLver'.'tsvtLrel'.'tsvtLmod
  SAY 'TSO:' tsoLev

  /* JES version */
  CALL EnumJes cvtJesct

  /* VTAM version */
  CALL EnumVtam cvtExt2
RETURN

/*------------------------------------------------------------------*/
/* Enumerate JES information                                        */
/*------------------------------------------------------------------*/
EnumJes: PROCEDURE
  PARSE ARG cvtJesct

  jesSsct = GetPtr(cvtJesct+24)
  jesPjesn = GetStorage(cvtJesct+28, 4)
  ssctsNam = GetStorage(jesSsct+8, 4)

  DO UNTIL jesSsct == 0
    IF jesPjesn == ssctsNam THEN DO
      ssctSsvt = GetPtr(jesSsct+16)
      ssctSuse = GetPtr(jesSsct+20)
      ssctSus2 = GetPtr(jesSsct+28)
      LEAVE
    END
    jesSsct = GetPtr(jesSsct+4)
  END

  IF jesPjesn == 'JES3' THEN DO
    jesVers = SYSVAR('SYSJES')
    jesNode = SYSVAR('SYSNODE')
  END
  ELSE IF jesPjesn == 'JES2' THEN DO
    jesVers = STRIP(GetStorage(ssctSuse, 8))
    jesNode = GetJes2Node(jesVers, ssctSus2)
  END

  SAY 'JES:' jesPjesn jesVers 'Node:' jesNode
RETURN

/*------------------------------------------------------------------*/
/* Get JES2 node name based on version                             */
/*------------------------------------------------------------------*/
GetJes2Node: PROCEDURE
  PARSE ARG jesVers, ssctSus2

  prefix = SUBSTR(jesVers, 1, 8)

  SELECT
    WHEN prefix == 'z/OS 2.2' THEN
      jesNode = STRIP(GetStorage(ssctSus2+664, 8))
    WHEN prefix == 'z/OS 2.1' | prefix == 'z/OS1.13' |,
         prefix == 'z/OS1.12' | prefix == 'z/OS1.11' THEN
      jesNode = STRIP(GetStorage(ssctSus2+656, 8))
    WHEN prefix == 'z/OS1.10' | prefix == 'z/OS 1.9' THEN
      jesNode = STRIP(GetStorage(ssctSus2+708, 8))
    WHEN prefix == 'z/OS 1.8' THEN
      jesNode = STRIP(GetStorage(ssctSus2+620, 8))
    WHEN prefix == 'z/OS 1.7' THEN
      jesNode = STRIP(GetStorage(ssctSus2+616, 8))
    WHEN prefix == 'z/OS 1.5' | prefix == 'z/OS 1.4' THEN
      jesNode = STRIP(GetStorage(ssctSus2+532, 8))
    WHEN SUBSTR(jesVers,1,7) == 'OS 2.10' |,
         prefix == 'z/OS 1.2' THEN
      jesNode = STRIP(GetStorage(ssctSus2+452, 8))
    WHEN SUBSTR(jesVers,1,6) == 'OS 1.1' |,
         SUBSTR(jesVers,1,4) == 'SP 5' THEN
      jesNode = STRIP(GetStorage(ssctSus2+336, 8))
    WHEN SUBSTR(jesVers,1,5) == 'OS 1.' |,
         SUBSTR(jesVers,1,5) == 'OS 2.' THEN
      jesNode = STRIP(GetStorage(ssctSus2+372, 8))
    OTHERWISE
      jesNode = SYSVAR('SYSNODE')
  END

RETURN jesNode

/*------------------------------------------------------------------*/
/* Enumerate VTAM information                                       */
/*------------------------------------------------------------------*/
EnumVtam: PROCEDURE
  PARSE ARG cvtExt2

  chkVtAct = GetStorage(cvtExt2+64, 1)

  IF BITAND(chkVtAct, '80'x) == '80'x THEN DO
    cvtAtcvt = C2D(GetStorage(cvtExt2+65, 3))
    istAtcvt = GetPtr(cvtAtcvt)
    atcvtLvl = GetStorage(istAtcvt, 8)
    vtamVer = SUBSTR(atcvtLvl, 3, 1)
    vtamRel = SUBSTR(atcvtLvl, 4, 1)
    vtamMod = SUBSTR(atcvtLvl, 5, 1)

    IF vtamMod == ' ' THEN vtamLev = vtamVer'.'vtamRel
    ELSE vtamLev = vtamVer'.'vtamRel'.'vtamMod

    atcNetid = STRIP(GetStorage(istAtcvt+2080, 8))
    atcNqnam = STRIP(GetStorage(istAtcvt+2412, 17))

    SAY 'VTAM:' vtamLev '(NETID:' atcNetid')',
      '(SSCPNAME:' atcNqnam')'
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate SVC table                                              */
/*------------------------------------------------------------------*/
EnumSvc: PROCEDURE EXPOSE (findingsVars)

  CALL PrintSectionBanner 'SVC Table'
  IF assessMode == 0 THEN DO
    SAY 'Installed SVCs (APF authorized only):'
  END
  ELSE DO
    SAY 'Installed SVCs:'
  END
  SAY 'SVCEP    | SVC | HX | TYPE | APF | ESR'
  SAY '---------|-----|----|------|-----|----'

  cvt = GetPtr(16)
  cvtAbend = GetPtr(cvt+200)
  scvtSvct = GetPtr(cvtAbend+132)
  cvtNucmp = GetPtr(cvt+1200)
  nucmAddr = GetPtr(cvtNucmp+8)

  /* Find IGCERROR address */
  nucmap = cvtNucmp + 16
  DO WHILE nucmap <= nucmAddr
    IF GetStorage(nucmap, 8) == 'IGCERROR' THEN DO
      igcError = GetStorage(nucmap+8, 4)
      LEAVE
    END
    nucmap = nucmap + 16
  END

  /* Iterate through SVC table */
  DO i = 0 TO 255
    addr = BITAND(GetStorage(scvtSvct+(i*8), 4), '7FFFFFFF'x)

    IF igcError \== addr THEN DO
      svcType = GetStorage(scvtSvct+(i*8)+4, 1)

      /* Determine type */
      SELECT
        WHEN BITAND(svcType, '80'x) == '80'x THEN type = '2'
        WHEN BITAND(svcType, 'C0'x) == 'C0'x THEN type = '3/4'
        WHEN BITAND(svcType, '20'x) == '20'x THEN type = '6'
        WHEN BITAND(svcType, 'F0'x) == '00'x THEN type = '1'
        OTHERWISE type = '?'
      END

      /* Check APF and ESR flags */
      IF BITAND(svcType, '08'x) == '08'x THEN apf = 'Y'
      ELSE apf = 'N'

      IF BITAND(svcType, '04'x) == '04'x THEN esr = 'Y'
      ELSE esr = 'N'

      /* If not in assess mode, only show APF authorized SVCs */
      IF assessMode == 0 THEN DO
        IF apf == 'Y' THEN DO
          SAY C2X(GetStorage(scvtSvct+(i*8), 4)) '|',
            RIGHT(i, 3, 0) '|' RIGHT(D2X(i), 2, 0) '|',
            type '  |' apf '|' esr
        END
      END
      ELSE DO
        /* In assess mode, show all SVCs */
        SAY C2X(GetStorage(scvtSvct+(i*8), 4)) '|',
          RIGHT(i, 3, 0) '|' RIGHT(D2X(i), 2, 0) '|',
          type '  |' apf '|' esr
      END
    END
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate dataset concatenations (PATH)                         */
/*------------------------------------------------------------------*/
EnumPath: PROCEDURE EXPOSE (globalvars)
  PARSE ARG lvl
  
  CALL PrintSectionBanner 'DDNAME Concatenations'

  IF lvl < 1 THEN lvl = 0

  psAlccav = C2D(STORAGE('21C', 4))
  tcbTio = GetPtr(psAlccav+12)
  tiot = tcbTio + 24
  tioElngh = 0
  dd = ''

  IF lvl < 1 THEN DO
    SAY 'Only displaying SYSPROC/SYSEXEC'
    SAY ''
    SAY 'DD       | DATASET Name'
    SAY '---------|' || COPIES('-', 44)
  END
  ELSE DO
    SAY 'DD       | VOLUME | DATASET Name'
    SAY '---------|--------|' || COPIES('-', 44)
  END

  DO FOREVER
    tiot = tiot + tioElngh
    tioElngh = C2D(GetStorage(tiot, 1))
    IF tioElngh == 0 THEN LEAVE

    tioEddnm = GetStorage(tiot+4, 8)
    IF tioEddnm \== '        ' THEN dd = tioEddnm

    dsnAddr = Swareq(GetStorage(tiot+12, 3))
    dataset = STRIP(GetStorage(dsnAddr, 44))
    volume = GetStorage(X2D(dsnAddr)+118, 6)

    IF lvl < 1 THEN DO
      IF dd == 'SYSPROC ' | dd == 'SYSEXEC ' THEN
        SAY dd '|' dataset
    END
    ELSE SAY dd '|' volume '|' dataset
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate master catalog                                         */
/*------------------------------------------------------------------*/
EnumCatalog: PROCEDURE
  cvt = GetPtr(16)
  ecvt = GetPtr(cvt+140)
  ecvtIpa = GetPtr(ecvt+392)
  ipaScat = GetStorage(ecvtIpa+224, 63)
  mcatDsn = STRIP(SUBSTR(ipaScat, 11, 44))
  mcatVol = SUBSTR(ipaScat, 1, 6)

  SAY 'Master Catalog:' mcatDsn 'Volume:' mcatVol
RETURN

/*------------------------------------------------------------------*/
/* Test TESTAUTH authorization                                      */
/*------------------------------------------------------------------*/
EnumTestauth: PROCEDURE

  CALL PrintSectionBanner 'TESTAUTH Authorization'
  ADDRESS 'TSO' 'NEWSTACK'
  QUEUE 'END'
  rc = OUTTRAP('out.')
  ADDRESS 'TSO' "TESTAUTH 'SYS1.LINKLIB(ICEPRML)'"
  rc = OUTTRAP('OFF')
  ADDRESS 'TSO' 'DELSTACK'

  IF out.0 == 0 THEN
    SAY 'You ARE authorized to use TESTAUTH <-'
  ELSE
    SAY out.1
RETURN

/*------------------------------------------------------------------*/
/* Enumerate TSO authorized command/program tables                 */
/*------------------------------------------------------------------*/
EnumTsoTables: PROCEDURE EXPOSE (findingsVars)

  CALL PrintSectionBanner 'TSO Authorization Tables'
  cvt = C2X(GetStorage(16, 4))
  tsvt = GetStorageHex(cvt, '9C')
  tpvt = GetStorageHex(tsvt, '4C')
  ctlt = GetStorageHex(tpvt, '14')

  SAY cvt': CVT' tsvt': TSVT' tpvt': TPVT' ctlt': CTLT'

  ctltSize = C2D(GetStorage(X2D(ctlt)+4, 2))

  DO i = 8 TO ctltSize - 5 BY 12
    table = GetStorageHex(ctlt, D2X(i))
    size = C2D(GetStorage(X2D(ctlt)+i+6, 2))
    entries = C2D(GetStorage(X2D(ctlt)+i+8, 2))
    length = C2D(GetStorage(X2D(ctlt)+i+10, 2))
    name = GetStorage(X2D(table), 8)

    SELECT
      WHEN name == 'IKJEFTE2' THEN name = name'/AUTHCMD'
      WHEN name == 'IKJEFTE8' THEN name = name'/AUTHPGM'
      WHEN name == 'IKJEFTNS' THEN name = name'/NOTBKGND'
      WHEN name == 'IKJEFTAP' THEN name = name'/AUTHTSF'
      OTHERWISE name = name'/UNKNOWN'
    END

    /* Determine if we should show this table */
    showTable = 1
    IF assessMode == 0 THEN DO
      /* Not in assess mode - only show AUTHCMD and AUTHTSF (if IDCAMS present) */
      IF POS('AUTHCMD', name) == 0 & POS('AUTHTSF', name) == 0 THEN DO
        showTable = 0
      END
      /* For AUTHTSF, check if IDCAMS is present before showing */
      ELSE IF POS('AUTHTSF', name) > 0 THEN DO
        hasIdcams = 0
        DO j = 2 TO entries
          ent = GetStorage(X2D(table)+(length*j), length)
          IF POS('IDCAMS', ent) > 0 THEN DO
            hasIdcams = 1
            LEAVE
          END
        END
        IF hasIdcams == 0 THEN showTable = 0
      END
    END

    IF showTable == 1 THEN DO
      SAY ''
      SAY name 'ENTRIES:' entries-1
      SAY ''

      output = ''
      idcamsFound = 0
      DO j = 2 TO entries
        ent = GetStorage(X2D(table)+(length*j), length)
        IF ent == ' PARMLIB' THEN ITERATE

        /* Check for IDCAMS in AUTHTSF table */
        IF POS('AUTHTSF', name) > 0 & POS('IDCAMS', ent) > 0 THEN DO
          idcamsFound = 1
        END

        output = output ent

        IF LENGTH(output) > 60 THEN DO
          SAY output
          output = ''
        END
      END

      IF output \== '' THEN SAY output

      /* Add finding if IDCAMS found in AUTHTSF */
      IF idcamsFound == 1 & assessMode == 1 THEN DO
        CALL AddFinding 'TSO-IDCAMS-IN-AUTHTSF'
        CALL AddVerificationCaption 'Using REXX execute the program ENUM',
          'available at http://github.com/mainframed/ and observe that',
          'IDCAMS is present in the IKJEFTAP/AUTHTSF table.'
        CALL AddVerificationContent '(TRUNCATED)/n',
          'IKJEFTAP/AUTHTSF contains IDCAMS/n(TRUNCATED)'
      END
    END
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate USS/OMVS users                                         */
/*------------------------------------------------------------------*/
EnumUssUsers: PROCEDURE

  CALL PrintSectionBanner 'z/OS UNIX Users'
  CALL syscalls 'ON'
  ADDRESS syscall

  ucount = 0

  DO FOREVER
    'getpwent pw.'
    IF retval == 0 | retval == -1 THEN LEAVE

    name = STRIP(pw.pw_name)
    uid = STRIP(pw.pw_uid)
    gid = STRIP(pw.pw_gid)
    home = STRIP(pw.pw_dir)
    ucount = ucount + 1
    usr.ucount = LEFT(name, 8) LEFT(gid, 10),
      LEFT(uid, 10) LEFT(home, 48)
    usr.0 = ucount
  END

  SAY 'USS/OMVS user details:'
  SAY COPIES('-', 41)
  SAY LEFT('USER ID', 8) LEFT('GID', 10),
    LEFT('UID', 10) LEFT('HOME', 10)

  DO i = 1 TO usr.0
    SAY usr.i
  END
RETURN

/*------------------------------------------------------------------*/
/* Enumerate RACF SETROPTS settings                                */
/*------------------------------------------------------------------*/
EnumSetropts: PROCEDURE EXPOSE (findingsVars) warningDatasets,
  excessiveUaccDatasets excessiveAccessDatasets
  PARSE ARG rcvt

  cvt = GetPtr(16)
  rcvx = GetPtr(cvt+X2D('3E0'))

  SAY ''
  SAY 'SETROPTS Info:'

  /* UADS dataset */
  rcvtUads = STRIP(GetStorage(rcvt+100, 44))
  SAY ''
  SAY 'UADS Dataset:'
  SAY 'UACC | WARN | ACCESS | DATASET'
  SAY '-----|------|--------|' || COPIES('-', 44)

  /* Check access for UADS dataset - READ access is a finding */
  outputUads = CheckAndReportDatasetAccess(rcvtUads, '', '', 1)
  SAY outputUads

  /* Parse fields for findings */
  PARSE VAR outputUads uadsUacc '|' uadsWarn '|' uadsAccess '|' .
  uadsUacc = STRIP(uadsUacc)
  uadsWarn = STRIP(uadsWarn)
  uadsAccess = STRIP(uadsAccess)

  /* Add findings for UADS dataset */
  IF assessMode == 1 THEN DO
    /* Check for user access to UADS dataset */
    IF uadsAccess \== 'NONE' THEN DO
      CALL AddFinding 'RACF-UADS-DATASET-ACCESS'
      CALL AddVerificationCaption 'Run the REXX script ENUM with the',
        'SEC argument and observe that the testing account has READ or',
        'greater access to the UADS dataset.'
      CALL AddVerificationContent 'UACC | WARN | ACCESS | DATASET'||,
        ' -----|------|--------|---------------------------------'||,
        ' '||outputUads
    END

    /* Check for excessive UACC on UADS dataset */
    IF uadsUacc \== 'NONE' THEN DO
      CALL AddFinding 'RACF-UADS-EXCESSIVE-UACC'
      CALL AddVerificationCaption 'Run the REXX script ENUM with the',
        'SEC argument and observe that the UADS dataset has a UACC',
        'of READ or greater.'
      CALL AddVerificationContent 'UACC | WARN | ACCESS | DATASET'||,
        ' -----|------|--------|---------------------------------'||,
        ' '||outputUads
    END

    /* Check for WARNING mode on UADS dataset */
    IF uadsWarn == 'YES' THEN DO
      CALL AddFinding 'RACF-UADS-WARNING-MODE'
      CALL AddVerificationCaption 'Run the REXX script ENUM with the',
        'SEC argument and observe that the UADS dataset is configured',
        'with WARNING mode enabled.'
      CALL AddVerificationContent 'UACC | WARN | ACCESS | DATASET'||,
        ' -----|------|--------|---------------------------------'||,
        ' '||outputUads
    END
  END
  SAY ''

  /* Get bit flags */
  rcvtPro = rcvx + 393
  rcvtErop = rcvx + 154
  rcvtAuop = rcvx + 151
  rcvtProx = X2B(C2X(GetStorage(rcvtPro, 4)))
  rcvtErox = X2B(C2X(GetStorage(rcvtErop, 4)))
  rcvtAuox = X2B(C2X(GetStorage(rcvtAuop, 8)))

  /* Command violations */
  IF SUBSTR(rcvtErox, 3, 1) == 0 THEN
    SAY 'RACF Command violations are logged'
  ELSE DO
    SAY 'RACF Command violations are not logged'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-COMMAND-VIOLATIONS-NOT-LOGGED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF command violations are not logged.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'RACF Command violations are not logged/n(TRUNCATED)'
    END
  END

  /* PROTECT-ALL */
  IF SUBSTR(rcvtProx, 1, 1) == 1 THEN DO
    SAY 'PROTECT-ALL is on'
    IF SUBSTR(rcvtProx, 2, 1) == 1 THEN DO
      SAY ' PROTECT-ALL WARNING mode'
      IF assessMode == 1 THEN DO
        CALL AddFinding 'RACF-PROTECT-ALL-WARNING-MODE'
        CALL AddVerificationCaption 'Using REXX execute the program ENUM',
          'available at http://github.com/mainframed/ with the argument',
          'SEC and observe that PROTECT-ALL is in WARNING mode.'
        CALL AddVerificationContent '(TRUNCATED)/n',
          'PROTECT-ALL is on/n PROTECT-ALL WARNING mode/n(TRUNCATED)'
      END
    END
    ELSE
      SAY ' PROTECT-ALL FAILURE mode'
  END
  ELSE DO
    SAY 'PROTECT-ALL is off'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-PROTECT-ALL-DISABLED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that PROTECT-ALL is disabled.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'PROTECT-ALL is off/n(TRUNCATED)'
    END
  END

  /* ERASE-ON-SCRATCH */
  IF SUBSTR(rcvtProx, 3, 1) == 1 THEN DO
    SAY 'ERASE-ON-SCRATCH is active, current options:'
    IF SUBSTR(rcvtProx, 4, 1) == 1 THEN
      SAY ' ERASE-ON-SCRATCH BY SECLEVEL is on'
    ELSE
      SAY ' ERASE-ON-SCRATCH BY SECLEVEL is off'
    IF SUBSTR(rcvtProx, 5, 1) == 1 THEN
      SAY ' ERASE-ON-SCRATCH for all datasets is on'
    ELSE
      SAY ' ERASE-ON-SCRATCH for all datasets is off'
  END
  ELSE DO
    SAY 'ERASE-ON-SCRATCH is off'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-ERASE-ON-SCRATCH-DISABLED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that ERASE-ON-SCRATCH is disabled.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'ERASE-ON-SCRATCH is off/n(TRUNCATED)'
    END
  END

  /* Audit settings */
  CALL EnumAuditSettings rcvtAuox, rcvtErox

  /* Password settings */
  CALL EnumPasswordSettings rcvt
RETURN

/*------------------------------------------------------------------*/
/* Enumerate RACF audit settings                                    */
/*------------------------------------------------------------------*/
EnumAuditSettings: PROCEDURE EXPOSE (findingsVars)
  PARSE ARG rcvtAuox, rcvtErox

  IF SUBSTR(rcvtAuox, 2, 1) == 1 THEN
    SAY 'GROUP changes are audited'
  ELSE DO
    SAY 'GROUP changes are not audited'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-GROUP-CHANGES-NOT-AUDITED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF GROUP changes are not audited.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'GROUP changes are not audited/n(TRUNCATED)'
    END
  END

  IF SUBSTR(rcvtAuox, 3, 1) == 1 THEN
    SAY 'USER changes are audited'
  ELSE DO
    SAY 'USER changes are not audited'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-USER-CHANGES-NOT-AUDITED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF USER changes are not audited.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'USER changes are not audited/n(TRUNCATED)'
    END
  END

  IF SUBSTR(rcvtAuox, 4, 1) == 1 THEN
    SAY 'DATASET changes are audited'
  ELSE DO
    SAY 'DATASET changes are not audited'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-DATASET-CHANGES-NOT-AUDITED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF DATASET changes are not audited.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'DATASET changes are not audited/n(TRUNCATED)'
    END
  END

  IF SUBSTR(rcvtAuox, 5, 1) == 1 THEN
    SAY 'DASDVOL changes are audited'
  ELSE DO
    SAY 'DASDVOL changes are not audited'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-DASDVOL-CHANGES-NOT-AUDITED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF DASDVOL changes are not audited.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'DASDVOL changes are not audited/n(TRUNCATED)'
    END
  END

  IF SUBSTR(rcvtAuox, 6, 1) == 1 THEN
    SAY 'TAPEVOL changes are audited'
  ELSE DO
    SAY 'TAPEVOL changes are not audited'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-TAPEVOL-CHANGES-NOT-AUDITED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF TAPEVOL changes are not audited.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'TAPEVOL changes are not audited/n(TRUNCATED)'
    END
  END

  IF SUBSTR(rcvtAuox, 7, 1) == 1 THEN
    SAY 'TERMINAL changes are audited'
  ELSE DO
    SAY 'TERMINAL changes are not audited'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-TERMINAL-CHANGES-NOT-AUDITED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF TERMINAL changes are not audited.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'TERMINAL changes are not audited/n(TRUNCATED)'
    END
  END

  IF SUBSTR(rcvtErox, 4, 1) == 0 THEN
    SAY 'SPECIAL users are audited'
  ELSE DO
    SAY 'SPECIAL users are not audited'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-SPECIAL-USERS-NOT-AUDITED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF SPECIAL users are not audited.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'SPECIAL users are not audited/n(TRUNCATED)'
    END
  END

  IF SUBSTR(rcvtAuox, 8, 1) == 1 THEN
    SAY 'OPERATIONS users are audited'
  ELSE DO
    SAY 'OPERATIONS users are NOT audited'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-OPERATIONS-USERS-NOT-AUDITED'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF OPERATIONS users are not audited.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'OPERATIONS users are NOT audited/n(TRUNCATED)'
    END
  END

  SAY ''
RETURN

/*------------------------------------------------------------------*/
/* Enumerate RACF password settings                                */
/*------------------------------------------------------------------*/
EnumPasswordSettings: PROCEDURE EXPOSE (findingsVars)
  PARSE ARG rcvt

  cvt = GetPtr(16)
  rcvx = GetPtr(cvt+X2D('3E0'))

  /* RVARY passwords */
  rcvtSwpw = STRIP(GetStorage(rcvt+440, 8))
  foundSwpw = 0
  foundInpw = 0

  IF C2X(rcvtSwpw) == '0000000000000000' THEN
    SAY 'RVARY SWITCH password is set to default value of YES'
  ELSE DO
    foundSwpw = 1
    SAY 'RVARY SWITCH password DES hash:' C2X(rcvtSwpw)
  END

  rcvtInpw = STRIP(GetStorage(rcvt+448, 8))
  IF C2X(rcvtInpw) == '0000000000000000' THEN
    SAY 'RVARY STATUS password is set to default value of YES'
  ELSE DO
    foundInpw = 1
    SAY 'RVARY STATUS password DES hash:' C2X(rcvtInpw)
  END

  IF foundSwpw == 1 | foundInpw == 1 THEN DO
    SAY 'John the ripper RVARY cracking input:'
    IF foundSwpw == 1 THEN
      SAY 'SWITCH:'||'$rvary$'||C2X(rcvtSwpw)
    IF foundInpw == 1 THEN
      SAY 'STATUS:'||'$rvary$'||C2X(rcvtInpw)
  END
  SAY ''

  /* Password intervals */
  rcvtPinv = C2D(GetStorage(rcvt+155, 1))
  SAY 'Global password change interval:' rcvtPinv 'days'

  rcvtPmin = C2D(GetStorage(rcvt+634, 1))
  SAY 'Minimum password change interval:' rcvtPmin 'days'
  IF rcvtPmin < 1 & assessMode == 1 THEN DO
    CALL AddFinding 'RACF-MIN-PASSWORD-CHANGE-INTERVAL-WEAK'
    CALL AddVerificationCaption 'Using REXX execute the program ENUM',
      'available at http://github.com/mainframed/ with the argument',
      'SEC and observe that the minimum password change interval is less',
      'than 1 day.'
    CALL AddVerificationContent '(TRUNCATED)/n',
      'Minimum password change interval:' rcvtPmin 'days/n(TRUNCATED)'
  END

  /* Password syntax rules */
  CALL EnumPasswordRules rcvt

  /* Password constraints */
  rcvtSlen = C2D(STRIP(GetStorage(rcvt+244, 1)))
  IF rcvtSlen == 0 THEN rcvtSlen = 1
  SAY 'Minimum possible password length:' rcvtSlen
  IF rcvtSlen < 8 & assessMode == 1 THEN DO
    CALL AddFinding 'RACF-MIN-PASSWORD-LENGTH-WEAK'
    CALL AddVerificationCaption 'Using REXX execute the program ENUM',
      'available at http://github.com/mainframed/ with the argument',
      'SEC and observe that the minimum possible password length is less',
      'than 8 characters.'
    CALL AddVerificationContent '(TRUNCATED)/n',
      'Minimum possible password length:' rcvtSlen'/n(TRUNCATED)'
  END

  rcvtElen = C2D(STRIP(GetStorage(rcvt+245, 1)))
  IF rcvtElen == 0 THEN rcvtElen = 8
  SAY 'Maximum possible password length:' rcvtElen

  rcvtRvok = C2D(STRIP(GetStorage(rcvt+241, 1)))
  rcvtRvokNum = rcvtRvok  /* Keep numeric value for comparison */
  IF rcvtRvok == 0 THEN rcvtRvok = 'unlimited'
  SAY 'Invalid logon attempts allowed:' rcvtRvok
  IF (rcvtRvokNum > 5 | rcvtRvokNum == 0) & assessMode == 1 THEN DO
    CALL AddFinding 'RACF-INVALID-LOGON-ATTEMPTS-EXCESSIVE'
    CALL AddVerificationCaption 'Using REXX execute the program ENUM',
      'available at http://github.com/mainframed/ with the argument',
      'SEC and observe that the invalid logon attempts allowed is greater',
      'than 5 or unlimited.'
    CALL AddVerificationContent '(TRUNCATED)/n',
      'Invalid logon attempts allowed:' rcvtRvok'/n(TRUNCATED)'
  END

  rcvtInac = C2D(STRIP(GetStorage(rcvt+243, 1)))
  IF rcvtInac == '0' THEN DO
    SAY 'No inactive interval'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-NO-INACTIVE-INTERVAL'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that no inactive interval is configured.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'No inactive interval/n(TRUNCATED)'
    END
  END
  ELSE SAY 'Inactive interval:' rcvtInac 'days'

  rcvtHist = C2D(STRIP(GetStorage(rcvt+240, 1)))
  IF rcvtHist == '0' THEN DO
    SAY 'No password history in use'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-NO-PASSWORD-HISTORY'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that no password history is configured.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'No password history in use/n(TRUNCATED)'
    END
  END
  ELSE SAY 'Password history:' rcvtHist 'generations'

  /* Password options */
  CALL EnumPasswordOptions rcvx, rcvt
RETURN

/*------------------------------------------------------------------*/
/* Enumerate RACF password syntax rules                            */
/*------------------------------------------------------------------*/
EnumPasswordRules: PROCEDURE EXPOSE (findingsVars)
  PARSE ARG rcvt

  SAY 'Password syntax rules:'

  hasRules = 0
  DO i = 1 TO 8
    offset = 244 + ((i-1) * 10)
    minLen = GetStorage(rcvt+offset, 1)
    maxLen = GetStorage(rcvt+offset+1, 1)
    rule = STRIP(GetStorage(rcvt+offset+2, 8))

    IF C2X(maxLen) \== '00' THEN DO
      hasRules = 1
      IF C2X(rule) == '0000000000000000' THEN rule = '********'
      SAY ' Rule' i':' rule
      SAY '    Min length:' C2X(minLen)
      SAY '    Max length:' C2X(maxLen)
    END
  END

  IF hasRules == 0 THEN DO
    SAY ' ** No password rules defined! **'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-NO-PASSWORD-RULES'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that no password syntax rules are defined.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'Password syntax rules:/n ** No password rules defined! **/n(TRUNCATED)'
    END
  END
  ELSE
    SAY ' LEGEND: A-ALPHA C-CONSONANT L-ALPHANUM N-NUMERIC',
      'V-VOWEL W-NOVOWEL *-ANYTHING c-MIXED CONSONANT',
      'm-MIXED NUMERIC v-MIXED VOWEL $-NATIONAL s-SPECIAL'
RETURN

/*------------------------------------------------------------------*/
/* Enumerate RACF password options and features                    */
/*------------------------------------------------------------------*/
EnumPasswordOptions: PROCEDURE EXPOSE (findingsVars)
  PARSE ARG rcvx, rcvt

  rcvtFlg3 = rcvx + 633
  rcvtFlgx = X2B(C2X(GetStorage(rcvtFlg3, 8)))

  IF SUBSTR(rcvtFlgx, 2, 1) == 1 THEN
    SAY 'Mixed case passwords enabled'
  ELSE DO
    SAY 'Mixed case passwords disabled'
    /* Example: Add finding for mixed case disabled */
    CALL AddFinding 'RACF-MIXED-CASE-DISABLED'
    CALL AddVerificationCaption 'Using REXX execute the program ENUM',
      'available at http://github.com/mainframed/ with the argument',
      'SEC and observe that in RACF mixed case passwords are not enabled.'
    CALL AddVerificationContent '(TRUNCATED)/n',
      'Mixed case passwords disabled/n(TRUNCATED)'

  END

  IF SUBSTR(rcvtFlgx, 5, 1) == 1 THEN
    SAY 'Special characters are allowed in passwords'
  ELSE SAY 'Special characters are not allowed in passwords'

  IF SUBSTR(rcvtFlgx, 6, 1) == 1 THEN
    SAY 'Enhanced password options under OA43999 available'
  ELSE
    SAY 'Enhanced password options under OA43999 not available'

  IF SUBSTR(rcvtFlgx, 7, 1) == 1 THEN
    SAY 'Multi factor auth is available'
  ELSE SAY 'Multi factor auth is not available'

  rcvtFlg4 = rcvx + 640
  rcvtFlgy = X2B(C2X(GetStorage(rcvtFlg4, 8)))

  IF SUBSTR(rcvtFlgy, 2, 1) == 1 THEN
    SAY ' MFA3 is available (OA50930)'
  ELSE SAY ' MFA3 is not available (OA50930)'

  /* Password encryption */
  rcvtPalg = C2D(STRIP(GetStorage(rcvt+635, 1)))
  IF rcvtPalg == '1' THEN SAY 'KDFAES encryption is active'
  ELSE DO
    SAY 'Legacy encryption is active'
    IF assessMode == 1 THEN DO
      CALL AddFinding 'RACF-LEGACY-ENCRYPTION-ACTIVE'
      CALL AddVerificationCaption 'Using REXX execute the program ENUM',
        'available at http://github.com/mainframed/ with the argument',
        'SEC and observe that RACF is using legacy encryption instead of',
        'KDFAES encryption.'
      CALL AddVerificationContent '(TRUNCATED)/n',
        'Legacy encryption is active/n(TRUNCATED)'
    END
  END

  /* Password exit */
  pwx01hex = GetStorage(rcvt+236, 4)
  rcvtPwdx = C2D(BITAND(pwx01hex, '7FFFFFFF'x))

  IF rcvtPwdx == 0 THEN yesOrNo = 'is NOT'
  ELSE yesOrNo = 'IS'

  SAY 'There' yesOrNo 'a new password exit (ICHPWX01)',
    'installed.'
RETURN

/*==================================================================*/
/*                         HELPER FUNCTIONS                         */
/*==================================================================*/

/*------------------------------------------------------------------*/
/* Check dataset access (RACF only)                                */
/* Returns: 'UACC WARNING ACCESS' (e.g., 'NONE NO ALTER')          */
/*          or error message if checks fail                         */
/*------------------------------------------------------------------*/
CheckDatasetAccess: PROCEDURE
  PARSE ARG dataset

  /* First check if we're on RACF */
  cvt = GetPtr(16)
  cvtrac = GetPtr(cvt+992)
  id = GetStorage(cvtrac, 4)

  IF id \== 'RCVT' THEN DO
    RETURN 'ERROR: Not a RACF system'
  END

  /* Check if we can run LISTDSD */
  ADDRESS 'TSO'
  rc = OUTTRAP('checkOut.')
  'LISTDSD'
  rc = OUTTRAP('OFF')

  /* If command not found or not authorized */
  IF checkOut.0 > 0 THEN DO
    DO i = 1 TO checkOut.0
      IF POS('NOT AUTHORIZED', checkOut.i) > 0 |,
         POS('COMMAND NOT FOUND', checkOut.i) > 0 THEN DO
        RETURN 'ERROR: Cannot run LISTDSD command'
      END
    END
  END

  /* Try LISTDSD with the dataset */
  rc = OUTTRAP('out.')
  "LISTDSD da('"||STRIP(dataset)||"')"
  cmdRc = RC
  rc = OUTTRAP('OFF')

  /* Check if we got the "NO RACF DESCRIPTION FOUND" error */
  IF cmdRc \== 0 THEN DO
    foundNoDesc = 0
    DO i = 1 TO out.0
      IF POS('ICH35003I', out.i) > 0 THEN DO
        foundNoDesc = 1
        LEAVE
      END
    END

    /* Try with GENERIC option */
    IF foundNoDesc == 1 THEN DO
      rc = OUTTRAP('out.')
      "LISTDSD da('"||STRIP(dataset)||"') GENERIC"
      cmdRc = RC
      rc = OUTTRAP('OFF')

      /* If still fails, dataset is not RACF protected */
      IF cmdRc \== 0 THEN DO
        RETURN 'ERROR: Dataset not RACF protected'
      END
    END
    ELSE DO
      /* Different error */
      RETURN 'ERROR: LISTDSD command failed'
    END
  END

  /* Parse the output */
  uacc = ''
  warning = ''
  access = ''

  DO i = 1 TO out.0
    /* Look for the LEVEL line with UNIVERSAL ACCESS and WARNING */
    IF POS('UNIVERSAL ACCESS', out.i) > 0 THEN DO
      /* Next line should have the actual values */
      IF i < out.0 THEN DO
        n = i + 2
        nextLine = out.n
        /* Parse: " 00    PHIL            NONE          NO      NO" */
        PARSE VAR nextLine . . uacc warning .
        uacc = STRIP(uacc)
        warning = STRIP(warning)
      END
    END

    /* Look for YOUR ACCESS line */
    IF POS('YOUR ACCESS', out.i) > 0 THEN DO
      /* Next line should have the access value */
      IF i < out.0 THEN DO
        n = i + 2
        nextLine = out.n
        /* Parse: "   ALTER        SYS1           NON-VSAM" */
        PARSE VAR nextLine access .
        access = STRIP(access)
      END
    END
  END

  /* Validate we found all values */
  IF uacc == '' | warning == '' | access == '' THEN DO
    RETURN 'ERROR: Could not parse LISTDSD output'
  END

RETURN uacc || ' ' || warning || ' ' || access

/*------------------------------------------------------------------*/
/* Check dataset access and track findings                          */
/* Returns: formatted output string for display                     */
/* Side effects: Updates warningDatasets, excessiveUaccDatasets,    */
/*               and excessiveAccessDatasets variables              */
/* Parameters:                                                      */
/*   dataset - Dataset name to check                               */
/*   volume  - Volume name for display                             */
/*   missing - Missing status for display                          */
/*   checkRead - If 1, READ access is also a finding (default 0)   */
/*------------------------------------------------------------------*/
CheckAndReportDatasetAccess: PROCEDURE EXPOSE warningDatasets,
  excessiveUaccDatasets excessiveAccessDatasets
  PARSE ARG dataset, volume, missing, checkRead

  /* Default checkRead to 0 if not specified */
  IF checkRead == '' THEN checkRead = 0

  accessInfo = CheckDatasetAccess(STRIP(dataset))

  IF POS('ERROR:', accessInfo) == 0 THEN DO
    /* Parse the result: 'UACC WARNING ACCESS' */
    PARSE VAR accessInfo uacc warning access
    uaccDisp = LEFT(uacc, 4)
    warnDisp = LEFT(warning, 4)
    accessDisp = LEFT(access, 6)

    /* If volume/missing are empty, use simplified format */
    IF volume == '' & missing == '' THEN DO
      output = uaccDisp '|' warnDisp '|' accessDisp '|' STRIP(dataset)
    END
    ELSE DO
      output = LEFT(STRIP(volume),6) '|' STRIP(LEFT(missing,6)),
        '|' uaccDisp '|' warnDisp '|' accessDisp '|' STRIP(dataset)
    END

    /* Track findings */
    dsName = STRIP(dataset)

    /* Check for WARNING mode */
    IF warning == 'YES' THEN DO
      IF warningDatasets == '' THEN
        warningDatasets = ' ' || dsName
      ELSE
        warningDatasets = warningDatasets || ', ' || dsName
    END

    /* Check for excessive UACC - always check UPDATE/CONTROL/ALTER */
    /* For sensitive datasets (checkRead=1), also check READ */
    IF uacc == 'UPDATE' | uacc == 'CONTROL' | uacc == 'ALTER' THEN DO
      IF excessiveUaccDatasets == '' THEN
        excessiveUaccDatasets = ' ' || dsName
      ELSE
        excessiveUaccDatasets = excessiveUaccDatasets || ', ' || dsName
    END
    ELSE IF checkRead == 1 & uacc == 'READ' THEN DO
      IF excessiveUaccDatasets == '' THEN
        excessiveUaccDatasets = ' ' || dsName
      ELSE
        excessiveUaccDatasets = excessiveUaccDatasets || ', ' || dsName
    END

    /* Check for excessive user access */
    IF access == 'UPDATE' | access == 'CONTROL' | access == 'ALTER' THEN DO
      IF excessiveAccessDatasets == '' THEN
        excessiveAccessDatasets = ' ' || dsName
      ELSE
        excessiveAccessDatasets = excessiveAccessDatasets || ', ' || dsName
    END
    ELSE IF checkRead == 1 & access == 'READ' THEN DO
      IF excessiveAccessDatasets == '' THEN
        excessiveAccessDatasets = ' ' || dsName
      ELSE
        excessiveAccessDatasets = excessiveAccessDatasets || ', ' || dsName
    END
  END
  ELSE DO
    /* Error occurred, display placeholder */
    IF volume == '' & missing == '' THEN DO
      output = ' ??  |  ??  |   ??   |' STRIP(dataset)
    END
    ELSE DO
      output = LEFT(STRIP(volume),6) '|' STRIP(LEFT(missing,6)),
        '|  ??  |  ??  |   ??   |' STRIP(dataset)
    END
  END

RETURN output

/*------------------------------------------------------------------*/
/* Get LPAR name (SMFID) from system                               */
/*------------------------------------------------------------------*/
GetLparName: PROCEDURE

  lparName = MVSVAR("SYSNAME")  /* LPAR name */

RETURN lparName

/*------------------------------------------------------------------*/
/* Get pointer from storage                                         */
/*------------------------------------------------------------------*/
GetPtr: PROCEDURE
  PARSE ARG addr
RETURN C2D(STORAGE(D2X(addr), 4))

/*------------------------------------------------------------------*/
/* Get storage at address                                           */
/*------------------------------------------------------------------*/
GetStorage: PROCEDURE
  PARSE ARG addr, len
RETURN STORAGE(D2X(addr), len)

/*------------------------------------------------------------------*/
/* Get storage using hex address                                    */
/*------------------------------------------------------------------*/
GetStorageHex: PROCEDURE
  PARSE ARG addr, disp
RETURN C2X(STORAGE(D2X(X2D(addr)+X2D(disp)), 4))

/*------------------------------------------------------------------*/
/* Get userid from ASCB                                             */
/*------------------------------------------------------------------*/
GetUserid: PROCEDURE
  PARSE ARG ascb

  assb = GetPtr(ascb+336)
  jsab = GetPtr(assb+168)

  IF jsab == 0 THEN usid = ''
  ELSE usid = GetStorage(jsab+44, 8)

RETURN usid

/*------------------------------------------------------------------*/
/* Add element to array                                             */
/*------------------------------------------------------------------*/
AddToArray: PROCEDURE EXPOSE (globalVars)
  PARSE ARG arrayName, value

  INTERPRET 'idx = ' || arrayName || '.0 + 1'
  INTERPRET arrayName || '.' || idx || ' = value'
  INTERPRET arrayName || '.0 = idx'
RETURN

/*------------------------------------------------------------------*/
/* Convert SWA Virtual Address to 31-bit address                    */
/* Credit: Gilbert Saint-Flour                                      */
/*------------------------------------------------------------------*/
Swareq: PROCEDURE
  sva = C2D(ARG(1))
  tcb = C2D(STORAGE('21C', 4))
  jscb = GetPtr(tcb+180)
  qmpl = GetPtr(jscb+244)

  /* Check if QMAT can be above the bar */
  qmsta = C2X(GetStorage(qmpl+16, 1))

  IF SUBSTR(X2B(qmsta), 6, 1) THEN DO
    /* QMAT can be ATB */
    IF RIGHT(X2B(C2X(ARG(1))), 1) \== '1' THEN
      RETURN C2D(ARG(1)) + 16

    qmat = C2D(GetStorage(qmpl+10, 2)) * (2**48) +,
      C2D(GetStorage(qmpl+18, 2)) * (2**32) +,
      GetPtr(qmpl+24)

    RETURN GetPtr(qmat+(sva*12)+64) + 16
  END
  ELSE DO
    /* QMAT is BTB */
    IF RIGHT(C2X(ARG(1)), 1) \== 'F' THEN
      RETURN C2D(ARG(1)) + 16

    qmat = GetPtr(qmpl+24)

    DO WHILE sva > 65536
      qmat = GetPtr(qmat+12)
      sva = sva - 65536
    END

    RETURN GetPtr(qmat+sva+1) + 16
  END

/*------------------------------------------------------------------*/
/* Print section separator                                          */
/*------------------------------------------------------------------*/
PrintSeparator: PROCEDURE
  SAY COPIES('-', 72)
  SAY ''
RETURN

/*------------------------------------------------------------------*/
/* Print section banner with header                                 */
/*------------------------------------------------------------------*/
PrintSectionBanner: PROCEDURE
  PARSE ARG sectionTitle

  SAY ''
  SAY '$$$$$$$$$$$$$$$$$$$$$$$$$'
  SAY '$$Y'''
  SAY '$$'
  SAY '$$' sectionTitle
  SAY '$$'
  SAY '$$b.'
  SAY '$$$$$$$$$$$$$$$$$$$$$$$$$'
  SAY ''
RETURN

/*------------------------------------------------------------------*/
/* Print banner text                                                */
/*------------------------------------------------------------------*/
PrintBanner: PROCEDURE
  PARSE ARG text
  SAY text
RETURN

/*==================================================================*/
/*              ASSESSMENT MODE FUNCTIONS (OSS VERSION)             */
/*==================================================================*/
/*                                                                  */
/* NOTE: This open source version contains simplified examples of  */
/* the assessment mode functions. The actual implementation would   */
/* track and report real security findings discovered during the    */
/* enumeration process.                                             */
/*                                                                  */
/* Example usage pattern for adding findings:                       */
/*                                                                  */
/* 1. Add EXPOSE clause to your enumeration procedure:              */
/*    PROCEDURE EXPOSE (findingsVars)                               */
/*                                                                  */
/* 2. When a security issue is detected, call:                      */
/*    CALL AddFinding 'FINDING-TEMPLATE-ID'                         */
/*    CALL AddVerificationCaption 'Title for verification step'     */
/*    CALL AddVerificationContent 'Detailed evidence and steps'     */
/*                                                                  */
/* 3. You can add multiple verification steps per finding           */
/*==================================================================*/

/*------------------------------------------------------------------*/
/* Add a finding to the assessment results                          */
/*------------------------------------------------------------------*/
AddFinding: PROCEDURE EXPOSE (findingsVars)
  IF assessMode == 0 THEN RETURN  /* Only add findings in assess mode */

  PARSE ARG templateId

  idx = findings.0 + 1
  findingtemplate.idx = templateId
  verificationcaption.idx = ''
  verificationsteps.idx = ''

  findings.0 = idx
  findingtemplate.0 = idx
  verificationcaption.0 = idx
  verificationsteps.0 = idx
RETURN

/*------------------------------------------------------------------*/
/* Add verification caption to the most recent finding              */
/* This is the title/heading for the verification step             */
/*------------------------------------------------------------------*/
AddVerificationCaption: PROCEDURE EXPOSE (findingsVars)
  IF findings.0 == 0 THEN RETURN  /* No findings to add to */

  PARSE ARG caption

  idx = findings.0  /* Get most recent finding */

  /* Append to caption (first one has no delimiter prefix) */
  IF verificationcaption.idx == '' THEN
    verificationcaption.idx = caption
  ELSE
    verificationcaption.idx = verificationcaption.idx||VSTEP_DELIM||caption
RETURN

/*------------------------------------------------------------------*/
/* Add verification content to the most recent finding              */
/* This is the detailed content for the verification step           */
/* Must be called after AddVerificationCaption                      */
/*------------------------------------------------------------------*/
AddVerificationContent: PROCEDURE EXPOSE (findingsVars)
  IF findings.0 == 0 THEN RETURN  /* No findings to add to */

  PARSE ARG content

  idx = findings.0  /* Get most recent finding */

  /* Append to steps (first one has no delimiter prefix) */
  IF verificationsteps.idx == '' THEN
    verificationsteps.idx = content
  ELSE
    verificationsteps.idx = verificationsteps.idx||VSTEP_DELIM||content
RETURN

/*------------------------------------------------------------------*/
/* Output assessment results                                        */
/*------------------------------------------------------------------*/
OutputAssessmentJSON: PROCEDURE EXPOSE (findingsVars)

  CALL PrintSectionBanner 'Assessment Findings'

  DO i = 1 TO findings.0
    templateId = findingtemplate.i

    /* Parse verification captions and steps */
    captions = verificationcaption.i
    steps = verificationsteps.i

    SAY ''
    SAY 'Finding' i||':' templateId
    SAY COPIES('-', 60)

    /* Parse and output verification steps */
    IF captions \== '' THEN DO
      captionPos = 1
      stepPos = 1

      DO WHILE captionPos > 0
        /* Find next delimiter position */
        nextCaptionDelim = POS(VSTEP_DELIM, captions, captionPos)
        nextStepDelim = POS(VSTEP_DELIM, steps, stepPos)

        /* Extract caption */
        IF nextCaptionDelim > 0 THEN DO
          vCaption = SUBSTR(captions, captionPos,,
            nextCaptionDelim - captionPos)
          captionPos = nextCaptionDelim + LENGTH(VSTEP_DELIM)
        END
        ELSE DO
          vCaption = SUBSTR(captions, captionPos)
          captionPos = 0  /* Signal end */
        END

        /* Extract step */
        IF nextStepDelim > 0 THEN DO
          vContent = SUBSTR(steps, stepPos, nextStepDelim - stepPos)
          stepPos = nextStepDelim + LENGTH(VSTEP_DELIM)
        END
        ELSE DO
          vContent = SUBSTR(steps, stepPos)
          stepPos = 0
        END

        /* Output verification caption and content */
        SAY vCaption
        SAY vContent
        SAY ''
      END
    END
  END
RETURN

/*------------------------------------------------------------------*/
/* Escape special characters for JSON strings                       */
/*------------------------------------------------------------------*/
JsonEscape: PROCEDURE
  PARSE ARG text

  /* Replace backslash first */
  text = ReplaceStr(text, '\', '\\')
  /* Replace double quotes */
  text = ReplaceStr(text, '"', '\"')

RETURN text

/*------------------------------------------------------------------*/
/* Return placeholder for open curly brace                         */
/*------------------------------------------------------------------*/
OpenCurly: PROCEDURE
RETURN '<<LC>>'

/*------------------------------------------------------------------*/
/* Return placeholder for close curly brace                        */
/*------------------------------------------------------------------*/
CloseCurly: PROCEDURE
RETURN '<<RC>>'

/*------------------------------------------------------------------*/
/* Return placeholder for open square bracket                      */
/*------------------------------------------------------------------*/
OpenSquare: PROCEDURE
RETURN '<<LB>>'

/*------------------------------------------------------------------*/
/* Return placeholder for close square bracket                     */
/*------------------------------------------------------------------*/
CloseSquare: PROCEDURE
RETURN '<<RB>>'

/*------------------------------------------------------------------*/
/* Replace all occurrences of a string                              */
/*------------------------------------------------------------------*/
ReplaceStr: PROCEDURE
  PARSE ARG text, old, new

  DO WHILE POS(old, text) > 0
    p = POS(old, text)
    text = SUBSTR(text, 1, p-1) || new ||,
      SUBSTR(text, p+LENGTH(old))
  END

RETURN text

@@
//*********************************************************************
//PUTFSTJ EXEC PUTFILE,FILENAME='FileSystemTraversal.java'
//PUTFILE.SYSUT1 DD DATA,DLM='@@'
import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.PosixFilePermission;
import java.util.*;

// To compile: javac FileSystemTraversal.java


// This has been formatted to fit in an 80 column
// dataset/pds, hence the weird indentation
public class FileSystemTraversal {
 private static boolean includeDirs = true;
 private static boolean onlyExecutable = false;
 private static boolean onlyWritable = true;
 private static boolean onlyReadable = false;
 private static boolean flagsSpecified = false;
 private static PrintWriter output = null;

 public static void main(String[] args) {
     if (args.length < 1) {
System.out.println("Usage: java FileSystemTraversal [flags] <directory_path>");
System.out.println("Default: shows writable files and directories");
System.out.println("Flags:");
System.out.println("  -d (include directories)");
System.out.println("  -x (only executable files)");
System.out.println("  -w (only writable files)");
System.out.println("  -r (only readable files)");
System.out.println("  -a (both -d and -x)");
System.out.println("  -f <filename> (output to file)");
System.exit(1);
     }

     List<String> argList = new ArrayList<>(Arrays.asList(args));
     String directoryPath = argList.remove(argList.size() - 1);

     // If any filter flags are specified, reset defaults
     for (String arg : argList) {
      if (arg.equals("-d") || arg.equals("-x") || arg.equals("-w") ||
          arg.equals("-r") || arg.equals("-a")) {
          flagsSpecified = true;
          break;
      }
     }
     if (flagsSpecified) {
      includeDirs = false;
      onlyExecutable = false;
      onlyWritable = false;
      onlyReadable = false;
     }

     for (int i = 0; i < argList.size(); i++) {
      String arg = argList.get(i);
      switch (arg) {
       case "-d":
           includeDirs = true;
           break;
       case "-x":
           onlyExecutable = true;
           break;
       case "-w":
           onlyWritable = true;
           break;
       case "-r":
           onlyReadable = true;
           break;
       case "-a":
           includeDirs = true;
           onlyExecutable = true;
           break;
       case "-f":
        if (i + 1 < argList.size()) {
            String outputFile = argList.get(++i);
            try {
                output = new PrintWriter(new FileWriter(outputFile));
            } catch (IOException e) {
                System.err.println("Error opening output file: " + 
                                    e.getMessage());
                System.exit(1);
            }
        } else {
      System.out.println("Error: Output file name is required with -f flag.");
        System.exit(1);
        }
        break;
       default:
           System.out.println("Unknown flag: " + arg);
           System.exit(1);
      }
     }

     traverseDirectory(new File(directoryPath));

     if (output != null) {
         output.close();
     }
 }

 private static void traverseDirectory(File directory) {
     File[] files = directory.listFiles();
     if (files != null) {
         for (File file : files) {
             boolean shouldPrint = true;
             
             if (onlyReadable && !file.canRead()) {
                 shouldPrint = false;
             }
             if (onlyExecutable && !file.canExecute()) {
                 shouldPrint = false;
             }
             if (onlyWritable && !file.canWrite()) {
                 shouldPrint = false;
             }

             if (file.isDirectory()) {
                 if (includeDirs && shouldPrint) {
                     printFileInfo(file, true);
                 }
                 traverseDirectory(file);
             } else if (shouldPrint) {
                 printFileInfo(file, false);
             }
         }
     }
 }

 private static void printFileInfo(File file, boolean isDirectory) {
  try {
   Path path = Paths.get(file.getAbsolutePath());
   Set<PosixFilePermission> permissions = Files.getPosixFilePermissions(path);
   String permissionString = getPermissionString(permissions);
   String outputString = (isDirectory ? "d" : "") + permissionString 
                          + " " + file.getAbsolutePath();
   
   if (output != null) {
       output.println(outputString);
   } else {
       System.out.println(outputString);
   }
  } catch (Exception e) {
      System.err.println("Error accessing file: " + file.getAbsolutePath());
  }
 }

 private static String getPermissionString(
    Set<PosixFilePermission> permissions
    ) {
  StringBuilder sb = new StringBuilder();
  sb.append(permissions.contains(
   PosixFilePermission.OWNER_READ) ? "r" : "-");
  sb.append(permissions.contains(
   PosixFilePermission.OWNER_WRITE) ? "w" : "-");
  sb.append(permissions.contains(
   PosixFilePermission.OWNER_EXECUTE) ? "x" : "-");
  sb.append(permissions.contains(
   PosixFilePermission.GROUP_READ) ? "r" : "-");
  sb.append(permissions.contains(
   PosixFilePermission.GROUP_WRITE) ? "w" : "-");
  sb.append(permissions.contains(
   PosixFilePermission.GROUP_EXECUTE) ? "x" : "-");
  sb.append(permissions.contains(
   PosixFilePermission.OTHERS_READ) ? "r" : "-");
  sb.append(permissions.contains(
   PosixFilePermission.OTHERS_WRITE) ? "w" : "-");
  sb.append(permissions.contains(
   PosixFilePermission.OTHERS_EXECUTE) ? "x" : "-");
  return sb.toString();
 }
}
@@
//*********************************************************************
//PUTPOMVS EXEC PUTFILE,FILENAME='OMVSEnum.sh'
//PUTFILE.SYSUT1 DD DATA,DLM='@@'
#!/bin/sh
# Special Thanks: @bigendiansmalls for some commands and help
# Mainframe hackers 4 lyfe

# based on LinEnum.sh
#Config
useful="nc netcat wget nmap gcc python curl"
compilers="c89 c99 c++ xlc cc javac"
username=`logname`

## TODO

 
###################### END CONFIG ################################


version="version 0.1b"
usage() 
{
    
echo "\n\
##################################################################\n\
# Local USS Enumeration & Privilege Escalation Script            #\n\
##################################################################\n\
# Soldier of FORTRAN  |  @mainframed767                          #\n\
##################################################################\n\
# $version\n\
# Based on LinEnum.sh\n\
# Example: $0 -k keyword -r report -e /tmp/ -t\n\
OPTIONS:\n\
-k\tEnter keyword\n\
-e\tEnter export location\n\
-r\tEnter report name\n\
-t\tThorough tests (takes longer)\n\
-h\tDisplays this help text\n\
\n\
Running with no options = limited scans/no output file\n\
##################################################################"
# useful binaries (thanks to https://gtfobins.github.io/)
set binarylist = 'aria2c\|arp\|ash\|awk\|base64\|\
bash\|busybox\|cat\|chmod\|chown\|cp\|csh\|\
curl\|cut\|dash\|date\|dd\|diff\|dmsetup\|\
docker\|ed\|emacs\|env\|expand\|expect\|file\|\
find\|flock\|fmt\|fold\|ftp\|gawk\|gdb\|gimp\|\
git\|grep\|head\|ht\|iftop\|ionice\|ip$\|irb\|\
jjs\|jq\|jrunscript\|ksh\|ld.so\|ldconfig\|\
less\|logsave\|lua\|make\|man\|mawk\|more\|mv\|\
mysql\|nano\|nawk\|nc\|netcat\|nice\|nl\|nmap\|\
node\|od\|openssl\|perl\|pg\|php\|pic\|pico\|\
python\|readelf\|rlwrap\|rpm\|rpmquery\|rsync\|\
ruby\|run-parts\|rvim\|scp\|script\|sed\|\
setarch\|sftp\|sh\|shuf\|socat\|sort\|sqlite3\|\
ssh$\|start-stop-daemon\|stdbuf\|strace\|\
systemctl\|tail\|tar\|taskset\|tclsh\|tee\|\
telnet\|tftp\|time\|timeout\|ul\|unexpand\|\
uniq\|unshare\|vi\|vim\|watch\|wget\|wish\|\
xargs\|xxd\|zip\|zsh'

}

header()
{
echo "\n##############################################################"
echo "# Local USS Enumeration & Privilege Escalation Script      #"
echo "##############################################################"
echo "# Soldier of FORTRAN  |  @mainframed767                    #"
echo "##############################################################"
echo "# $version" 
echo "# Time: " `date`

}

footer()
{
echo "\n#######  Scan complete ##############################"
echo "# Time: " `date` "\n\n"
}

debug_info()
{
echo "[-] Debug Info" 

if [ "$keyword" ]; then 
  echo "[+] Searching for keyword $keyword in" \
       "conf, php, ini and log files" 
fi

if [ "$report" ]; then 
  echo "[+] Report name = $report" 
fi

if [ "$export" ]; then 
  echo "[+] Export location = $export" 
fi

if [ "$thorough" ]; then 
  echo "[+] Thorough tests = Enabled" 
else 
  echo "[+] Thorough tests = Disabled" 
fi

sleep 2

if [ "$export" ]; then
  mkdir $export 2>/dev/null
  format=$export/USSEnum-export-`date +"%d-%m-%y"`
  mkdir $format 2>/dev/null
fi

who=`whoami` 2>/dev/null 
}


system_info()
{
echo "\n#######  System Info ############################\n"


#basic kernel info
unameinfo=`uname -Ia 2>/dev/null`
if [ "$unameinfo" ]; then
  echo "[-] Kernel information: $unameinfo" 
fi

#target hostname info
hostnamed=`hostname 2>/dev/null`
if [ "$hostnamed" ]; then
  echo "[-] Hostname: $hostnamed" 
fi

# The name of the system (LPAR)
sysname=`sysvar SYSNAME 2>/dev/null`
if [ "$sysname" ]; then
  echo "[-] LPAR Name: $sysname" 
fi

# The version, release, and modification level of the operating system 
# software product
# Zxvvrrmm where
#          Zx is the operating system (for example, Z1 is z/OS)
#          vv is the version number from ECVTPVER (for example, 02)
#          rr is the release number from ECVTPREL (for example, 01)
#          mm is the modification number from
#          ECVTPMOD (for example, 00).
#          Example For z/OS 2.1, the value is Z1020100.
sysoslvl=`sysvar SYSOSLVL 2>/dev/null`
if [ "$sysoslvl" ]; then
  echo "[-] OS version: $sysoslvl" 
fi

sysver=`sysvar SYSVER 2>/dev/null`
if [ "$sysver" ]; then
  echo "[-] System Version: $sysver" 
fi

unixver=`sysvar UNIXVER 2>/dev/null`
if [ "$unixver" ]; then
  echo "[-] Unix Version: $unixver" 
fi

# The IPL Volume Serial name
sysr1=`sysvar SYSR1 2>/dev/null`
if [ "$sysr1" ]; then
  echo "[-] IPL Volume Serial: $sysr1" 
fi

# The architecture level of the system
sysalvl=`sysvar SYSALVL 2>/dev/null`
if [ "$sysalvl" ]; then
  echo "[-] Architecture level of the system: $sysalvl" 
fi

# Shorthand notation for the name of the system;
# often used in fields limited to two characters.
sysclone=`sysvar SYSCLONE 2>/dev/null`
if [ "$sysclone" ]; then
  echo "[-] Shorthand notation for the name of the system: $sysclone" 
fi

# The name of the sysplex.
sysplex=`sysvar SYSPLEX 2>/dev/null`
if [ "$sysplex" ]; then
  echo "[-] Name of the sysplex: $sysplex" 
fi

# ADCD?
adcdlvl=`sysvar ADCDLVL 2>/dev/null`
if [ "$adcdlvl" ]; then
  echo "[-] Running ADCD version: $adcdlvl" 
fi


# Unknown - maybe add later?
#&SYSC1.
#&SYSP1.
#&SYSP2.
#&SYSP3.
#&SYSR2.
#&SYSS1.

}

user_info()
{
echo "\n#######  User/ Group ############################\n"

#current user details
currusr=`id 2>/dev/null`
if [ "$currusr" ]; then
  echo "[-] Current user/group info:\n $currusr" 
  echo "\n"
fi

#current user details RACF
currusr=`/bin/tsocmd LU 2>/dev/null`
if [ "$currusr" ]; then
  racf=`true`
  echo "[-] Current user/group RACF info:\n $currusr" 
  echo "\n"
fi

#current user details TopSecret
currusr=`/bin/tsocmd TSS WHOAMI 2>/dev/null`
if [ "$currusr" ]; then
  echo "[-] Current user/group TSS info:\n $currusr" 
  echo "\n"
fi

# Owner of the root file system
uidzero=`ls -ald /|awk '{print $3}'`
if [ "$uidzero" ]; then
  echo "[-] Root user ID: $uidzero"; id $uidzero 
  echo "\n"
fi

# Display group information
usernum=`/bin/tsocmd lg 2>/dev/null|grep -ni "USER(S)="|cut -d":" -f1`
if [ "$usernum" -ne "" ]; then
  total_lines=`/bin/tsocmd lg 2>/dev/null|wc|awk '{print $1}'`
  group_lines=`expr $total_lines - $usernum`
  group_users=`/bin/tsocmd lg 2>/dev/null|tail -n $group_lines|\
               grep -v CONNECT|grep -v REVOKE|awk '{print "\t"$1}'`
  echo "[-] Default RACF group users:\n$group_users" 
fi

# Display subgroup information
if [ "$usernum" ]; then
  sub_group=`/bin/tsocmd lg 2>/dev/null|\
             grep -ni "SUBGROUP(S)="|\
             cut -d":" -f1`
  tail_num=`expr $usernum - $sub_group`
  head_num=`expr $usernum - 1`
  group_users=`/bin/tsocmd lg 2>/dev/null|head -n $head_num|\
               tail -n $tail_num|sed 's/SUBGROUP(S)=/            /'`
  if [ "$sub_group" ]; then
    echo "[-] Current RACF Subgroups:\n$group_users"
  fi
  if [ "$thorough" = "1" ]; then
    if [ "$sub_group" ]; then
      for i in $group_users; do
        usernum=`/bin/tsocmd lg $i 2>/dev/null|grep -ni "USER(S)="|\
                 cut -d":" -f1`
        if [ "$usernum" ]; then
          total_lines=`/bin/tsocmd lg $i \
                       2>/dev/null|wc|\
                       awk '{print $1}'`
          group_lines=`expr $total_lines - $usernum`
          group_users=`/bin/tsocmd lg $i \
                       2>/dev/null|\
                       tail -n $group_lines|\
                       grep -v CONNECT|\
                       grep -v REVOKE|\
                       awk '{print "\t"$1}'`
          echo "[-] Sub group $i users:\n$group_users" 
        fi
      done
      echo "[-] Current RACF group users:\n$group_users" 
      echo "\n"
    fi
  fi
fi

#who else is logged on
loggedonusrs=`who 2>/dev/null`
if [ "$loggedonusrs" ]; then
  echo "[-] Who else is logged on:\n$loggedonusrs" 
  echo "\n"
fi

#can we su without supplying a password
su -s << EOF 2>/dev/null
EOF

if [ "$?" -eq 0 ]; then
  echo "[+] We can su to root without supplying a password!"
  echo "\n"
fi

# Checks for system special
special=`/bin/tsocmd lu 2>/dev/null|grep SPECIAL`
if [ "$special" ]; then
  echo "[+] We are SYSTEM SPECIAL (RACF admin)!"
  echo "\n"
fi

# Checks for system operations
operations=`/bin/tsocmd lu 2>/dev/null|grep OPERATIONS`
if [ "$operations" ]; then
  echo "[+] We are SYSTEM OPERATIONS (read any dataset)!"
  echo "\n"
fi


#displays /u directory permissions - check if any are lax
homedirperms=`ls -Alp /u/ 2>/dev/null`
if [ "$homedirperms" ]; then
  echo "[-] Are permissions on /u directories lax:\n$homedirperms" 
  echo "\n"
fi

#looks for files we can write to that don't belong to us
# Needs FIXING!
if [ "$thorough" = "1" ]; then
  grfilesall=`find / -writable ! -user \`whoami\` -type f -exec ls \
              -al {} \; 2>/dev/null`
  if [ "$grfilesall" ]; then
    echo "[-] Files not owned by user but" \
         "writable by group:\n$grfilesall"
    echo "\n"
  fi
fi

#looks for files that belong to us
if [ "$thorough" = "1" ]; then
  ourfilesall=`find / -user \`whoami\` \
              -type f -exec ls -al {} \; \
              2>/dev/null`
  if [ "$ourfilesall" ]; then
    echo "[-] Files owned by our user:\n$ourfilesall"
    echo "\n"
  fi
fi

#looks for hidden files
if [ "$thorough" = "1" ]; then
  hiddenfiles=`find / -name ".*" -type f -exec ls -al {} \; 2>/dev/null`
  if [ "$hiddenfiles" ]; then
    echo "[-] Hidden files:\n$hiddenfiles"
    echo "\n"
  fi
fi

# looks for world-reabable files within /u - depending on number of /u 
# dirs & files, this can take some time so is
# only 'activated' with thorough scanning switch
if [ "$thorough" = "1" ]; then
wrfileshm=`find /u/ -perm -4 -type f -exec ls -al {} \; 2>/dev/null`
  if [ "$wrfileshm" ]; then
    echo "[-] World-readable files within /u:\n$wrfileshm" 
    echo "\n"
  fi
fi

if [ "$thorough" = "1" ]; then
  if [ "$export" ] && [ "$wrfileshm" ]; then
   mkdir $format/wr-files/ 2>/dev/null
   for i in $wrfileshm; do
     cp --parents $i $format/wr-files/
   done 2>/dev/null
  fi
fi

# lists current user's home directory contents
homedircontents=`ls -Alsk ~ 2>/dev/null`
if [ "$homedircontents" ] ; then
  echo "[-] Home directory contents:\n$homedircontents" 
  echo "\n" 
fi

# checks for if various ssh files are accessible
# this can take some time so is only 'activated'
# with thorough scanning switch
if [ "$thorough" = "1" ]; then
sshfiles=`find / \( -name "id_dsa*" \
          -o -name "id_rsa*" \
          -o -name "known_hosts" \
          -o -name "authorized_hosts" \
          -o -name "authorized_keys" \) \
          -exec ls -la {} 2>/dev/null \;`
  if [ "$sshfiles" ]; then
    echo "[-] SSH keys/host information found in the \
following locations:\n$sshfiles" 
    echo "\n"
  fi
fi

if [ "$thorough" = "1" ]; then
  if [ "$export" ] && [ "$sshfiles" ]; then
    mkdir $format/ssh-files/ 2>/dev/null
    for i in $sshfiles; do
      cp --parents $i $format/ssh-files/
    done 2>/dev/null
  fi
fi

#is root permitted to login via ssh
sshrootlogin=`grep "PermitRootLogin " \
              /etc/ssh/sshd_config \
              2>/dev/null | \
              grep -v "#" | \
              awk '{print  $2}'`
if [ "$sshrootlogin" = "yes" ]; then
  echo "[-] Root is allowed to login via SSH:"
  grep "PermitRootLogin " \
  /etc/ssh/sshd_config 2>/dev/null |\
  grep -v "#"
  echo "\n"
fi

# Dump the automount config
if [ -f /etc/auto.master ]
then
    echo "[-] Automounht config (/etc/auto.master):"
    cat /etc/auto.master
    echo
    cat /etc/auto.master | awk '{print $NF}' | while read line
    do
        if [ -f "$line" ]
        then
            echo "$line:"
            cat "$line"
            echo
        fi
    done
fi
}

environmental_info()
{

echo "\n#######  Environmental ##########################\n"

#env information
envinfo=`env 2>/dev/null | grep -v 'LS_COLORS' 2>/dev/null`
if [ "$envinfo" ]; then
  echo "[-] Environment information:\n$envinfo" 
  echo "\n"
fi

#current path configuration
pathinfo=`echo $PATH 2>/dev/null`
if [ "$pathinfo" ]; then
  echo "[-] Path information:\n$pathinfo" 
  echo "\n"
fi

#current umask value with both octal and symbolic output
umaskvalue=`umask -S 2>/dev/null & umask 2>/dev/null`
if [ "$umaskvalue" ]; then
  echo "[-] Current umask value:\n$umaskvalue" 
  echo "\n"
fi
}

job_info()
{
echo "\n#######  Jobs/Tasks #############################\n"

#are there any cron jobs configured
cronjobs=`ls -la /etc/cron* 2>/dev/null`
if [ "$cronjobs" ]; then
  echo "[-] Cron jobs:\n$cronjobs" 
  echo "\n"
fi

#can we manipulate these jobs in any way
cronjobwwperms=`find /etc/cron* -perm -0002 -type f -exec ls \
                -la {} \; -exec cat {} 2>/dev/null \;`
if [ "$cronjobwwperms" ]; then
  echo "[+] World-writable cron jobs and" \
       "file contents:\n$cronjobwwperms"
  echo "\n"
fi

#contab contents
crontabvalue=`cat /etc/crontab 2>/dev/null`
if [ "$crontabvalue" ]; then
  echo "[-] Crontab contents:\n$crontabvalue" 
  echo "\n"
fi

crontabvar=`ls -la /var/spool/cron/crontabs 2>/dev/null`
if [ "$crontabvar" ]; then
  echo "[-] Anything interesting in" \
       "/var/spool/cron/crontabs:\n$crontabvar"
  echo "\n"
fi

}

networking_info()
{
echo "\n#######  Networking #############################"

#nic information
nicinfo=`netstat -h 2>/dev/null`
if [ "$nicinfo" ]; then
  echo "[-] Network and IP info:\n$nicinfo" 
  echo "\n"
fi

arpinfo=`netstat -R ALL 2>/dev/null`
if [ "$arpinfo" ]; then
  echo "[-] ARP history:\n$arpinfo" 
  echo "\n"
fi

#dns settings
DNSdomainname=`dnsdomainname 2> /dev/null`
if [ "$DNSdomainname" ]; then
  echo "[-] Hostname:\n$DNSdomainname" 
  echo "\n"
fi

dnsserver=`dnsdomainname|grep Server|sed 's/Server:    //' 2> /dev/null`
if [ "$dnsserver" ]; then
  echo "[-] DNS Server:\n$dnsserver" 
  echo "\n"
fi

#default route configuration
defroute=`netstat -r 2>/dev/null`
if [ "$defroute" ]; then
  echo "[-] Routes:\n$defroute" 
  echo "\n"
fi

#default route configuration
defrouteip=`netstat -r 2>/dev/null | grep Default`
if [ ! "$defroute" ] && [ "$defrouteip" ]; then
  echo "[-] Default route:\n$defrouteip" 
  echo "\n"
fi

#listening TCP
tcpservs=`netstat 2>/dev/null|grep -v UDP|grep Listen`
if [ "$tcpservs" ]; then
  echo "[-] Listening TCP:\n$tcpservs" 
  echo "\n"
fi

#Connected TCP
tcpservs=`netstat 2>/dev/null|grep -v UDP|grep -v Listen`
if [ "$tcpservs" ]; then
  echo "[-] Established TCP:\n$tcpservs" 
  echo "\n"
fi


#listening UDP
udpservs=`netstat 2>/dev/null|grep UDP`
if [ "$udpservs" ]; then
  echo "[-] Listening UDP:\n$udpservs" 
  echo "\n"
fi

}

services_info()
{

echo "\n#######  Services   #############################\n"

#running processes
# OMVS is more secure and only lets you list running processes
# We can do some grep magic here
username=`id -u -nr 2>/dev/null`

psef=`ps -ef 2>/dev/null |grep -v UID|grep -v $username`

if [ "$psef" ]; then 
  psef_good=`ps -ef 2>/dev/null`
  if [ "$psef_good" ]; then
    echo "[+] Access to list all processes:" \
         "\n[-] List processes:\n$psef_good"
    echo "\n" 
  fi
else 
  echo "[!] This user cannot list processes" \
       "for all users skipping steps\n"
fi

#anything 'useful' in inetd.conf
inetdread=`cat /etc/inetd.conf 2>/dev/null`
if [ "$inetdread" ]; then
  echo "[-] Contents of /etc/inetd.conf:\n$inetdread" 
  echo "\n"
fi

if [ "$export" ] && [ "$inetdread" ]; then
  mkdir $format/etc-export/ 2>/dev/null
  cp /etc/inetd.conf $format/etc-export/inetd.conf 2>/dev/null
fi

# very 'rough' command to extract associated
# binaries from inetd.conf & show permissions
inetdbinperms=`awk '{print $6}' /etc/inetd.conf 2>/dev/null |\
               xargs ls -laskL 2>/dev/null`
if [ "$inetdbinperms" ]; then
  echo "[-] The related inetd binary" \
       "permissions:\n$inetdbinperms"
  echo "\n"
fi

}

software_configs()
{
echo "\n#######  Sotfware   #############################\n"

#TODO: This needs to have more stuff added 
# - zosmf?
# - Websphere?
# 
#htpasswd check
if [ "$thorough" = "1" ]; then
  htpasswd=`find / -name .htpasswd -print -exec cat {} \; 2>/dev/null`
  if [ "$htpasswd" ]; then
      echo "[-] htpasswd found - could contain passwords:\n$htpasswd"
      echo "\n"
  fi
else
  echo "[-] Not in thorough mode nothing to see here"
fi

#############################################
### This is broken and needs fixing
# CICS USSHOME
#USSHOME=`find /usr/lpp/cicsts/ \
#         -exec ls -laE {} 2>/dev/null \; \
#         2>/dev/null`
#if [ "$USSHOME" ]; then
#    echo "[-] CICS Default File Permissions" \
#         "(/usr/lpp/cicsts)\n$USSHOME"
#    echo "\n"
#fi
#############################################

}

interesting_files()
{
echo "\n#######  Interesting Files   ####################\n"

#checks to see if various files are installed
#useful programs

echo "[-] Useful file locations:\n"  
for prog in $useful; do
  echo "which $prog" |/bin/tcsh -s
done
echo "\n" 

#installed compilers
echo "[-] Installed compilers:\n"
for prog in $compilers; do
  echo "which $prog" |/bin/tcsh -s|grep -v FSUC1306
done
echo "\n" 

javac=`find /usr/lpp/java -name javac -type f 2>/dev/null`
if [ "$javac" ]; then
  echo "[-] Java compilers:\n$javac"
  echo "\n"
fi


if [ "$thorough" = "1" ]; then
# OMVS can be massive so we put this all in a thorough search
#search for suid files
  findsuidapf=`find / \( -perm -4000 -o -ext a \) -type f \
               -exec ls -laE {} 2>/dev/null \;`
  if [ "$findsuidapf" ]; then
    echo "[-] SUID and APF files:\n$findsuidapf" 
    echo "\n"
  fi

  if [ "$export" ] && [ "$findsuidapf" ]; then
    mkdir $format/suid-apf-files/ 2>/dev/null
    for i in $findsuidapf; do
      cp $i $format/suid-files/
    done 2>/dev/null
  fi

  #list of 'interesting' suid files - feel free to make additions
  intsuid=`find / -perm -4000 -type f -exec ls -la {} \; 2>/dev/null |\
           grep -w $binarylist 2>/dev/null`
  if [ "$intsuid" ]; then
    echo "[+] Possibly interesting SUID files:\n$intsuid" 
    echo "\n"
  fi

  #lists word-writable suid files
  wwsuid=`find / -ext a -perm -4002 \
          -type f -exec ls -la {} \
          2>/dev/null \;`
  if [ "$wwsuid" ]; then
    echo "[+] World-writable SUID files:\n$wwsuid" 
    echo "\n"
  fi

  wwapf=`find ./ -ext a -perm -0002 \
         -type f -exec ls -laE {} \
         2>/dev/null \;`
  if [ "$wwapf" ]; then
    echo "[-] World-writeable APF files:\n$wwapf" 
    echo "\n"
  fi

  #lists world-writable suid files owned by root
  wwsuidrt=`find / -user $uidzero -perm -4002 -type f -exec ls \
            -la {} 2>/dev/null \;`
  if [ "$wwsuidrt" ]; then
    echo "[+] World-writable SUID files owned by $uidzero:\n$wwsuidrt" 
    echo "\n"
  fi

  #search for sgid files
  findsgid=`find / -perm -2000 -type f -exec ls -la {} 2>/dev/null \;`
  if [ "$findsgid" ]; then
    echo "[-] SGID files:\n$findsgid" 
    echo "\n"
  fi

  if [ "$export" ] && [ "$findsgid" ]; then
    mkdir $format/sgid-files/ 2>/dev/null
    for i in $findsgid; do cp $i $format/sgid-files/; done 2>/dev/null
  fi

  #list of 'interesting' sgid files
  #intsgid=`find / -perm -2000 -type f \
  #         -exec ls -la {} \; \
  #         2>/dev/null | \
  #         grep -w $binarylist 2>/dev/null`
  #if [ "$intsgid" ]; then
  #  echo "[+] Possibly interesting SGID files:\n$intsgid" 
  #  echo "\n"
  #fi

  #lists world-writable sgid files
  wwsgid=`find / -perm -2002 -type f -exec ls -la {} 2>/dev/null \;`
  if [ "$wwsgid" ]; then
    echo "[+] World-writable SGID files:\n$wwsgid" 
    echo "\n"
  fi

  #lists world-writable sgid files owned by root
  wwsgidrt=`find / -user $uidzero -perm -2002 -type f -exec ls \
           -la {} 2>/dev/null \;`
  if [ "$wwsgidrt" ]; then
    echo "[+] World-writable SGID files owned by root:\n$wwsgidrt" 
    echo "\n"
  fi
fi

#look for keys
keyfiles=`find /u/ -type f \
          -exec grep -l "PRIVATE KEY-----" \
          {} 2> /dev/null \;`
  if [ "$keyfiles" ]; then
      echo "[+] Secret keys found!:\n$keyfiles"
      echo "\n"
  fi

#look for git credential files - thanks djhohnstein
if [ "$thorough" = "1" ]; then
gitcredfiles=`find / -name ".git-credentials" 2>/dev/null`
  if [ "$gitcredfiles" ]; then
      echo "[+] Git credentials saved on the machine!:\n$gitcredfiles"
      echo "\n"
  fi
fi

#list all world-writable files
if [ "$thorough" = "1" ]; then
wwfiles=`find / ! -perm -2 -type f -exec ls -la {} 2>/dev/null \;`
  if [ "$wwfiles" ]; then
    echo "[-] World-writable files:\n$wwfiles" 
    echo "\n"
  fi
fi

if [ "$thorough" = "1" ]; then
  if [ "$export" ] && [ "$wwfiles" ]; then
    mkdir $format/ww-files/ 2>/dev/null
    for i in $wwfiles; do
      cp --parents $i $format/ww-files/
    done 2>/dev/null
  fi
fi

#are any .plan files accessible in /home
#(could contain useful information)
usrplan=`find /u/ -name *.plan \
         -exec ls -la {} \; \
         -exec cat {} 2>/dev/null \;`
if [ "$usrplan" ]; then
  echo "[-] Plan file permissions and contents:\n$usrplan" 
  echo "\n"
fi

if [ "$export" ] && [ "$usrplan" ]; then
  mkdir $format/plan_files/ 2>/dev/null
  for i in $usrplan; do
    cp --parents $i $format/plan_files/
  done 2>/dev/null
fi

# are there any .rhosts files accessible
# these may allow us to login as another user
rhostsusr=`find /u/ -name *.rhosts -exec ls -la {} 2>/dev/null \; \
           -exec cat {} 2>/dev/null \;`
if [ "$rhostsusr" ]; then
  echo "[+] rhost config file(s) and file contents:\n$rhostsusr" 
  echo "\n"
fi

if [ "$export" ] && [ "$rhostsusr" ]; then
  mkdir $format/rhosts/ 2>/dev/null
  for i in $rhostsusr; do
    cp --parents $i $format/rhosts/
  done 2>/dev/null
fi

if [ "$export" ] && [ "$bsdrhostsusr" ]; then
  mkdir $format/rhosts 2>/dev/null
  for i in $bsdrhostsusr; do
    cp --parents $i $format/rhosts/
  done 2>/dev/null
fi

rhostssys=`find /etc -iname hosts.equiv -exec ls -la {} 2>/dev/null \; \
           -exec cat {} 2>/dev/null \;`
if [ "$rhostssys" ]; then
  echo "[+] Hosts.equiv file and contents: \n$rhostssys" 
  echo "\n"
fi

if [ "$export" ] && [ "$rhostssys" ]; then
  mkdir $format/rhosts/ 2>/dev/null
  for i in $rhostssys; do
    cp --parents $i $format/rhosts/
  done 2>/dev/null
fi

#HFS/ZFS mount points
fstab=`df -kP 2>/dev/null|awk '{print "\t"$1 "\t\t" $6}'`
if [ "$fstab" ]; then
  echo "[-] Displaying partitions and filesystems "
  echo "$fstab"
  echo "\n"
fi

# use supplied keyword and cat *.conf files for
# potential matches - output will show line number
# within relevant file path where match is located
if [ "$keyword" = "" ]; then
  echo "[-] Can't search *.conf files as no keyword was entered\n" 
  else
    confkey=`find / -name *.conf -type f -exec grep \
             -ln $keyword {} \; 2>/dev/null`
    if [ "$confkey" ]; then
      echo "[-] Find keyword ($keyword) in .conf files (output format \
filepath:identified line number where keyword appears):\n$confkey" 
      echo "\n" 
     else 
  echo "[-] Find keyword ($keyword) in .conf files:" 
  echo "'$keyword' not found in any .conf files" 
  echo "\n" 
    fi
fi

if [ "$keyword" = "" ]; then
  :
  else
    if [ "$export" ] && [ "$confkey" ]; then
    confkeyfile=`find / -maxdepth 4 -name *.conf -type f -exec \
                 grep -ln $keyword {} \; 2>/dev/null`
      mkdir --parents \
      $format/keyword_file_matches/config_files/ \
      2>/dev/null
      for i in $confkeyfile; do cp --parents $i \
      $format/keyword_file_matches/config_files/ ; done 2>/dev/null
  fi
fi

#use supplied keyword and cat *.php files for
# potential matches - output will show line number
# within relevant file path where match is located
if [ "$keyword" = "" ]; then
  echo "[-] Can't search *.php files as no keyword was entered\n" 
  else
    phpkey=`find / -name *.php -type f -exec grep \
            -ln $keyword {} \; 2>/dev/null`
    if [ "$phpkey" ]; then
      echo "[-] Find keyword ($keyword) in .php files (output format \
filepath:identified line number where keyword appears):\n$phpkey" 
      echo "\n" 
     else 
  echo "[-] Find keyword ($keyword) in .php files:" 
  echo "'$keyword' not found in any .php files" 
  echo "\n" 
    fi
fi

# use supplied keyword and cat *.class files for
# potential matches - output will show line number
# within relevant file path where match is located
if [ "$keyword" = "" ]; then
  echo "[-] Can't search *.class files as no keyword was entered\n" 
  else
    classkey=`find / -name *.class -type f -exec grep \
              -ln $keyword {} \; 2>/dev/null`
    if [ "$classkey" ]; then
      echo "[-] Find keyword ($keyword) in .class files (output format \
filepath:identified line number where keyword appears):\n$classkey" 
      echo "\n" 
     else 
  echo "[-] Find keyword ($keyword) in .class files:" 
  echo "'$keyword' not found in any .class files" 
  echo "\n" 
    fi
fi

if [ "$keyword" = "" ]; then
  :
  else
    if [ "$export" ] && [ "$phpkey" ]; then
    phpkeyfile=`find / -maxdepth 10 -name *.php -type f -exec grep \
               -ln $keyword {} \; 2>/dev/null`
      mkdir --parents \
      $format/keyword_file_matches/php_files/ \
      2>/dev/null
      for i in $phpkeyfile; do cp --parents $i \
      $format/keyword_file_matches/php_files/ ; done 2>/dev/null
  fi
fi

# use supplied keyword and cat *.log files for
# potential matches - output will show line number
# within relevant file path where match is located
if [ "$keyword" = "" ];then
  echo "[-] Can't search *.log files as no keyword was entered\n" 
  else
    logkey=`find / -name *.log -type f -exec grep \
            -ln $keyword {} \; 2>/dev/null`
    if [ "$logkey" ]; then
      echo "[-] Find keyword ($keyword) in .log files (output format \
filepath:identified line number where keyword appears):\n$logkey" 
      echo "\n" 
     else 
  echo "[-] Find keyword ($keyword) in .log files:" 
  echo "'$keyword' not found in any .log files"
  echo "\n" 
    fi
fi

if [ "$keyword" = "" ];then
  :
  else
    if [ "$export" ] && [ "$logkey" ]; then
      logkeyfile=`find / -name *.log -type f -exec grep \
                  -ln $keyword {} \; 2>/dev/null`
    mkdir --parents $format/keyword_file_matches/log_files/ 2>/dev/null
      for i in $logkeyfile; do cp --parents $i \
      $format/keyword_file_matches/log_files/ ; done 2>/dev/null
  fi
fi

#use supplied keyword and cat *.ini files for
# potential matches - output will show line number
# within relevant file path where match is located
if [ "$keyword" = "" ];then
  echo "[-] Can't search *.ini files as no keyword was entered\n" 
  else
    inikey=`find / -name *.ini -type f -exec grep \
           -ln $keyword {} \; 2>/dev/null`
    if [ "$inikey" ]; then
      echo "[-] Find keyword ($keyword) in .ini files (output format \
filepath:identified line number where keyword appears):\n$inikey" 
      echo "\n" 
     else 
  echo "[-] Find keyword ($keyword) in .ini files:" 
  echo "'$keyword' not found in any .ini files" 
  echo "\n"
    fi
fi

if [ "$keyword" = "" ];then
  :
  else
    if [ "$export" ] && [ "$inikey" ]; then
    inikey=`find / -maxdepth 4 -name *.ini -type f -exec \
            grep -lHn $keyword {} \; 2>/dev/null`
      mkdir --parents \
      $format/keyword_file_matches/ini_files/ \
      2>/dev/null
      for i in $inikey; do cp --parents $i \
      $format/keyword_file_matches/ini_files/ ; done 2>/dev/null
  fi
fi

#quick extract of .conf files from /etc - only 1 level
allconf=`find /etc/ -name *.conf -type f -exec ls -la {} \; 2>/dev/null`
if [ "$allconf" ]; then
  echo "[-] All *.conf files in /etc:\n$allconf" 
  echo "\n"
fi

if [ "$export" ] && [ "$allconf" ]; then
  mkdir $format/conf-files/ 2>/dev/null
  for i in $allconf; do
    cp --parents $i $format/conf-files/
  done 2>/dev/null
fi

#extract any user history files that are accessible
usrhist=`ls -la ~/.*_history 2>/dev/null`
if [ "$usrhist" ]; then
  echo "[-] Current user's history files:\n$usrhist" 
  echo "\n"
fi

if [ "$export" ] && [ "$usrhist" ]; then
 mkdir $format/history_files/ 2>/dev/null
 for i in $usrhist; do
   cp --parents $i $format/history_files/
 done 2>/dev/null
fi

#can we read roots *_history files - could be passwords stored etc.
roothist=`ls -la /u/$uidzero/.*_history 2>/dev/null`
if [ "$roothist" ]; then
  echo "+] $uidzero's history files are accessible!\n$roothist" 
  echo "\n"
fi

if [ "$export" ] && [ "$roothist" ]; then
  mkdir $format/history_files/ 2>/dev/null
  cp $roothist $format/history_files/ 2>/dev/null
fi

#all accessible .bash_history files in /home
checkbashhist=`find /u/ -name .*history \
               -print -exec cat {} \
               2>/dev/null \;`
if [ "$checkbashhist" ]; then
  echo "[-] Location and contents (if accessible) of \
.*history file(s):\n$checkbashhist"
  echo "\n"
fi

#is there any mail accessible
readmail=`ls -la /var/mail 2>/dev/null`
if [ "$readmail" ]; then
  echo "[-] Any interesting mail in /var/mail:\n$readmail" 
  echo "\n"
fi

#can we read roots mail
readmailroot=`head /var/mail/root 2>/dev/null`
if [ "$readmailroot" ]; then
  echo "+] We can read /var/mail/root! (snippet below)\n$readmailroot" 
  echo "\n"
fi

if [ "$export" ] && [ "$readmailroot" ]; then
  mkdir $format/mail-from-root/ 2>/dev/null
  cp $readmailroot $format/mail-from-root/ 2>/dev/null
fi

#Can we write to any HFS/ZFS datasets?
mounteddataset=`df -kP 2>/dev/null|awk '{print $1}'|grep -v Filesystem`
if [ "$mounteddataset" ]; then
  listdsd=`/bin/tsocmd listdsd 2>/dev/null`
  if [ "$listdsd" ]; then
    echo "[-] Mounted Dataset Access:"
    for dataset in $mounteddataset; do
      listdsd=`/bin/tsocmd "listdsd dataset('$dataset')" 2>/dev/null`
      generic=''
      if echo $listdsd|grep -q ICH35003I; then
        listdsd=`/bin/tsocmd \
        "listdsd dataset('$dataset') GENERIC" \
        2>/dev/null`
        generic='GENERIC'
      fi
      if echo "$dataset" | grep -q "/"; then
        echo "\t NOT A DATASET \t $dataset"
        continue
      fi
      if echo $listdsd|grep -q ICH35002I; then
        echo "LISTDSD ACCESS DENIED \t $dataset"
        continue
      fi  
      if echo $listdsd|grep -q ICH35003I; then
        echo "\t UNPROTECTED \t $dataset"
      else
        accessline=`/bin/tsocmd "listdsd dataset('$dataset') $generic" \
        2>/dev/null|grep -ni "YOUR ACCESS"|cut -d":" -f1`
        linnum=`expr $accessline + 2`
        access=`/bin/tsocmd "listdsd dataset('$dataset') $generic" \
        2>/dev/null|head -n $linnum|tail -n 1|awk '{print $1}'`
        echo "\t $access \t\t $dataset"
      fi
    done
  fi
fi
echo "\n"

#checking if we can make APF files
tmpfilename=`head -3 /dev/urandom | tr -cd '[:alnum:]' | cut -c -5`
touch /tmp/$tmpfilename.omvsenum
extattr +a /tmp/$tmpfilename.omvsenum  2>/dev/null
if [ "$?" -eq 0 ]; then
  echo "[+] We can issue extattr +a!"
  echo "\n"
else
  echo "[-] We cannot issue extattr +a"
fi
deltmpfile=`rm /tmp/$tmpfilename.omvsenum`

}

hfs_permission_bypass()
{
echo "\n#######  HFS Permission Bypass Checks   #########\n"

echo "[-] Testing if RACF/ACF2/TSS dataset" \
     "permissions bypass Unix file perms"
echo "\n"

# Test 1: Check if we can read other users'
# files despite Unix permissions
echo "[-] Searching for readable files in" \
     "other users' home directories..."

# Look for files in /u that we shouldn't be
# able to read based on Unix perms
# Common targets: .profile, .ssh/*, .netrc, etc.
targets=".profile .bash_profile .bashrc"
targets="$targets .netrc .ssh/id_rsa"
targets="$targets .ssh/id_dsa .ssh/authorized_keys"
found_bypass=0

for userdir in /u/*; do
  if [ -d "$userdir" ]; then
    username=`basename $userdir`
    current_user=`whoami`

    # Skip our own directory
    if [ "$username" = "$current_user" ]; then
      continue
    fi

    # Try to read common sensitive files
    for target in $targets; do
      filepath="$userdir/$target"
      if [ -f "$filepath" ]; then
        # Check Unix permissions - look for files
        # we shouldn't be able to read
        perms=`ls -l "$filepath" 2>/dev/null | awk '{print $1}'`

        # Try to read the file
        content=`head -1 "$filepath" 2>/dev/null`
        read_result=$?
        if [ "$read_result" -eq 0 ]; then
          if [ -n "$content" ]; then
            # We could read it - check if perms say we shouldn't
            echo "$perms" | grep "^-rw-------" >/dev/null 2>&1
            perm_check1=$?
            echo "$perms" | grep "^-r--------" >/dev/null 2>&1
            perm_check2=$?
            if [ "$perm_check1" -eq 0 ] || \
               [ "$perm_check2" -eq 0 ]; then
              echo "[+] BYPASS DETECTED:" \
                   "Can read $filepath" \
                   "despite perms ($perms)"
              found_bypass=1
            fi
          fi
        fi
      fi
    done
  fi
done

if [ $found_bypass -eq 0 ]; then
  echo "[-] No obvious permission bypasses detected in /u/*"
fi
echo "\n"

# Test 2: Create our own test file with
# restrictive perms and verify we can read it
# This confirms the test methodology works
echo "[-] Creating test file with restrictive permissions..."
tmpfilename=`head -3 /dev/urandom | tr -cd '[a-zA-Z0-9]' | cut -c -5`
tmpfile="/tmp/$tmpfilename.permtest"
echo "secret_test_content_$$" > $tmpfile 2>/dev/null

if [ -f "$tmpfile" ]; then
  # Set to 000 (no permissions for anyone)
  chmod 000 $tmpfile 2>/dev/null

  # Try to read our own file with 000 permissions
  content=`cat $tmpfile 2>/dev/null`
  read_result=$?
  if [ "$read_result" -eq 0 ]; then
    if [ -n "$content" ]; then
      echo "[+] Can read our own file even with 000 permissions!"
      echo "[+] HFS Security permissions override Unix permissions"
      fperms=`ls -l $tmpfile 2>/dev/null |\
              awk '{print $1}'`
      echo "[-] File permissions: $fperms"
    else
      echo "[-] Cannot read own file with" \
           "000 perms (expected behavior)"
    fi
  else
    echo "[-] Cannot read own file with" \
         "000 perms (expected behavior)"
  fi

  # Cleanup
  chmod 600 $tmpfile 2>/dev/null
  rm $tmpfile 2>/dev/null
else
  echo "[-] Could not create test file"
fi

echo "\n"

# Test 3: Check if we can list directories we shouldn't have access to
echo "[-] Testing directory access despite Unix permissions..."
found_dir_bypass=0

for userdir in /u/*; do
  if [ -d "$userdir" ]; then
    username=`basename $userdir`
    current_user=`whoami`

    # Skip our own directory
    if [ "$username" = "$current_user" ]; then
      continue
    fi

    # Check if directory has restrictive permissions
    dirperms=`ls -ld "$userdir" 2>/dev/null | awk '{print $1}'`

    # Try to list it
    listing=`ls "$userdir" 2>/dev/null | head -1`
    list_result=$?
    if [ "$list_result" -eq 0 ]; then
      if [ -n "$listing" ]; then
        # Check if perms suggest we shouldn't be able to list
        echo "$dirperms" | grep "^drwx------" >/dev/null 2>&1
        dir_check1=$?
        echo "$dirperms" | grep "^dr-x------" >/dev/null 2>&1
        dir_check2=$?
        if [ "$dir_check1" -eq 0 ] || \
           [ "$dir_check2" -eq 0 ]; then
          echo "[+] BYPASS DETECTED:" \
               "Can list $userdir" \
               "despite perms ($dirperms)"
          found_dir_bypass=1
        fi
      fi
    fi
  fi
done

if [ $found_dir_bypass -eq 0 ]; then
  echo "[-] No directory permission bypasses detected"
fi

echo "\n"
}

chown_checks()
{
echo "\n#######  CHOWN Privilege Checks   ###########\n"

# Test for CHOWN_UNRESTRICTED and/or
# SUPERUSER.FILESYS.CHOWN
# Create a temporary test file
tmpfilename=`head -3 /dev/urandom | tr -cd '[a-zA-Z0-9]' | cut -c -5`
tmpfile="/tmp/$tmpfilename.chowntest"
touch $tmpfile 2>/dev/null

if [ ! -f "$tmpfile" ]; then
  echo "[-] Could not create test file for chown checks"
  echo "\n"
  return
fi

current_uid=`id -u`
echo "[-] Testing chown capabilities" \
     "(current UID: $current_uid)"
echo "\n"

# Test 1: Try to chown to UID 0
echo "[-] Attempting to change ownership to UID 0..."
chown 0 $tmpfile 2>/dev/null
chown_result=$?
if [ "$chown_result" -eq 0 ]; then
  file_owner=`ls -ln $tmpfile | awk '{print $3}'`
  if [ "$file_owner" = "0" ]; then
    echo "[+] SUCCESS: chown to UID 0 worked!" \
         "(CHOWN_UNRESTRICTED or" \
         "SUPERUSER.FILESYS.CHOWN likely)"

    # Try to change it back to our UID
    echo "[-] Attempting to chown back" \
         "to UID $current_uid..."
    chown $current_uid $tmpfile 2>/dev/null
    chown_back_result=$?
    if [ "$chown_back_result" -eq 0 ]; then
      file_owner=`ls -ln $tmpfile |\
                   awk '{print $3}'`
      if [ "$file_owner" = "$current_uid" ]; then
        echo "[+] SUCCESS: Changed back" \
             "to UID ($current_uid)"
      else
        echo "[-] FAILED: Could not verify" \
             "chown back (owner: $file_owner)"
      fi
    else
      echo "[-] FAILED: Could not change ownership back to our UID"
    fi
  else
    echo "[-] FAILED: File owner is $file_owner, not 0"
  fi
else
  echo "[-] FAILED: Could not change ownership to UID 0"
fi
echo "\n"

# Test 2: Find another UID from /u and test changing to that
echo "[-] Finding another user's UID from /u directory..."
other_uid=`ls -ln /u 2>/dev/null |\
           awk '{print $3}' |\
           grep -v "^$current_uid$" |\
           grep -v "^0$" | head -1`

if [ "$other_uid" != "" ]; then
  echo "[-] Found UID: $other_uid"
  echo "[-] Attempting to chown to" \
       "UID $other_uid..."

  # Reset file to our ownership first
  chown $current_uid $tmpfile 2>/dev/null

  # Try to change to other UID
  chown $other_uid $tmpfile 2>/dev/null
  chown_other_result=$?
  if [ "$chown_other_result" -eq 0 ]; then
    file_owner=`ls -ln $tmpfile | awk '{print $3}'`
    if [ "$file_owner" = "$other_uid" ]; then
      echo "[+] SUCCESS: Changed ownership to UID $other_uid"

      # Try to change it back
      echo "[-] Attempting to chown back" \
           "to UID $current_uid..."
      chown $current_uid $tmpfile 2>/dev/null
      chown_back2_result=$?
      if [ "$chown_back2_result" -eq 0 ]; then
        file_owner=`ls -ln $tmpfile |\
                     awk '{print $3}'`
        if [ "$file_owner" = "$current_uid" ]; then
          echo "[+] SUCCESS: Changed back" \
               "to UID ($current_uid)"
          echo "[+] We have unrestricted" \
               "chown capabilities!"
        else
          echo "[-] FAILED: Could not verify" \
               "chown back (owner: $file_owner)"
        fi
      else
        echo "[-] FAILED: Could not change ownership back to our UID"
      fi
    else
      echo "[-] FAILED: File owner is $file_owner, not $other_uid"
    fi
  else
    echo "[-] FAILED: Could not chown" \
         "to UID $other_uid"
  fi
else
  echo "[-] Could not find another UID to test with"
fi

# Clean up
rm $tmpfile 2>/dev/null
echo "\n"
}

racf_searches()
{
echo "\n#######  RACF Searches   ########################\n"

#Can we even issue the search command?

searchcmd=`/bin/tsocmd search 2>/dev/null`
if [ "$searchcmd" ]; then
  srchwrn=`/bin/tsocmd "SR ALL WARNING NOMASK" 2>/dev/null`
  if [ "$srchwrn" ]; then
    echo "[+] Datasets set to WARNING:\n$srchwrn"
    echo "\n"
  fi
    srchdsn=`/bin/tsocmd "SR FILTER(**)" 2>/dev/null`
  if [ "$srchdsn" ]; then
    echo "[+] READ or greater access to dataset rules:\n$srchdsn"
    echo "\n"
  fi
    srchupriv=`/bin/tsocmd "SR CLASS(UNIXPRIV)" 2>/dev/null`
  if [ "$srchupriv" ]; then
    echo "[+] Unix Privileged resources:\n$srchupriv"
    echo "\n"
  fi
    srchbpx=`/bin/tsocmd \
    "SEARCH CLASS(FACILITY) FILTER(BPX.**)" \
    2>/dev/null`
  if [ "$srchbpx" ]; then
    echo "[-] BPX Access:\n$srchbpx"
    echo "\n"
  fi
    srchsgt=`/bin/tsocmd \
    "SEARCH CLASS(SURROGAT) FILTER(*.SUBMIT)" \
    2>/dev/null`
  if [ "$srchsgt" ]; then
    echo "[+] Surrogate Access:\n$srchsgt"
    echo "\n"
  fi
srchsu=`/bin/tsocmd \
"SEARCH CLASS(SURROGAT) FILTER(BPX.SRV.ADMIN)" \
2>/dev/null`
  if [ "$srchsu" ]; then
    echo "[+] su access without password:\n$srchsu"
    echo "\n"
  fi
fi

}

call_each()
{
  header
  debug_info
  system_info
  user_info
  environmental_info
  networking_info
  services_info
  software_configs
  interesting_files
  hfs_permission_bypass
  chown_checks
  racf_searches
  footer
}

while getopts k:r:e:ht option; do
 case "$option" in
    k) keyword=$OPTARG;;
    r) report=$OPTARG"-"`date +"%d-%m-%y"`;;
    e) export=$OPTARG;;
    t) thorough=1;;
    h) usage; exit;;
    *) usage; exit;;
 esac
done

# Interesting commands:
# chaudit
# extattr
# Change path to /usr/sbin/ as well
# submit
# tsocmd

if echo $PATH|grep -q "/bin"; then
  :
else
  set PATH=$PATH:/bin
fi

if echo $PATH|grep -q sbin; then
  :
else
  set PATH=$PATH:/usr/sbin
fi

call_each | tee -a $report 2> /dev/null
@@
//*********************************************************************
//PUTPORTS EXEC PUTFILE,FILENAME='portscan.java'
//PUTFILE.SYSUT1 DD DATA,DLM='@@'
import java.net.SocketAddress;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.InetAddress;

// 
// Tool by Owen aka SirCICSAlot
// 

public class portscan
{
    public static void main(final String[] args) {
        int portStart = 0;
        int portEnd = 0;
        int timeout = 1000;
        boolean debug = false;
        int exit = 1;
        String line = "";
        System.out.println("PortScan by SirCICSalot");
        if (args.length < 3 || args[0].toString() == "help") {
System.out.println("Usage: java -cp . portscan" +
            " host, start port, end port,");
        System.out.println("       [-t timeout] [-d debug]");
            System.exit(exit);
        }
        String host = args[0];

        try {
            portStart = Integer.parseInt(args[1]);
            portEnd = Integer.parseInt(args[2]);
        } catch (NumberFormatException e) {
            System.err.println(
                "Invalid port format: " + e.getMessage());
            System.exit(exit);
        }
        
        // Process optional arguments
        for (int i = 3; i < args.length; i++) {
            String arg = args[i];
            if (arg.equals("-t")) {
                try {
                    timeout = Integer.parseInt(args[++i]);
                } catch (NumberFormatException e) {
                    System.err.println("Invalid timeout format: " + 
                                        e.getMessage());
                    System.exit(exit);
                }
            } else if (arg.equals("-d")) {
                debug = true;
            } else {
                System.err.println("Unknown option: " + arg);
                System.exit(exit);
            }
        }


        if (debug) {
            try {
                final InetAddress ia = InetAddress.getByName(host);
                System.out.println(ia.getHostAddress());
                System.out.println(
                    InetAddress.getLocalHost().toString());
                System.out.println("Timeout: " + timeout);
            }
            catch (Exception ex) {}
        }
        for (int port = portStart; port <= portEnd; ++port) {
            line = "[Timeout: " + timeout +
                "] [" + host + "] Current Port: " + port;
            if (debug) {
                System.out.println(line);
            } else if (port % 100 == 0){
                System.out.println(line);
            }
            try {
                final Socket socket = new Socket();
                socket.connect(
                    new InetSocketAddress(host, port),
                    timeout);
                socket.close();
                System.out.println("Port " + port + " is open");
                exit = 0;
            }
            catch (Exception ex2) {}
        }
    System.exit(exit);
    }
}
@@
//*********************************************************************
//* Run ENUM
//*********************************************************************
//ENUMREXX  EXEC PGM=BPXBATCH
//STDIN     DD DUMMY
//STDOUT    DD SYSOUT=*
//STDERR    DD SYSOUT=*     
//STDPARM   DD *
SH cd /u/mainframe;
 ./ENUM.rexx SEC; 
 ./ENUM.rexx SVC; 
 ./ENUM.rexx APF; 
 ./ENUM.rexx USSU;
//*********************************************************************
//* Run OMVSENUM
//*********************************************************************
//OMVSENUM  EXEC PGM=BPXBATCH
//STDIN     DD DUMMY
//STDOUT    DD SYSOUT=*
//STDERR    DD SYSOUT=*     
//STDPARM   DD *
SH cd /u/mainframe;
 sed 's/[[:space:]]*$//' OMVSEnum.sh > OMVSSed.sh;
 chmod +x OMVSSed.sh;
 ./OMVSSed.sh;
//*********************************************************************
//* Compile Java Program
//*********************************************************************
//JAVAC     EXEC PGM=BPXBATCH
//STDIN     DD DUMMY
//STDOUT    DD SYSOUT=*
//STDERR    DD SYSOUT=*     
//STDPARM   DD *
SH set JAVA_HOME=/usr/lpp/java/J8.0_64;
 cd /u/mainframe;
 /usr/lpp/java/J8.0_64/bin/javac  FileSystemTraversal.java;
 /usr/lpp/java/J8.0_64/bin/javac  portscan.java;
//*********************************************************************
//* Run FileSystemTraversal 
//*********************************************************************
//RUNFSTJ   EXEC PGM=BPXBATCH
//STDIN     DD DUMMY
//STDOUT    DD SYSOUT=*
//STDERR    DD SYSOUT=*     
//STDPARM   DD *
SH set JAVA_HOME=/usr/lpp/java/J8.0_64;
 cd /u/mainframe;
 /usr/lpp/java/J8.0_64/bin/java FileSystemTraversal -w /u > u.writeable.txt;
 /usr/lpp/java/J8.0_64/bin/java FileSystemTraversal -w /etc > etc.writeable.txt;
 /usr/lpp/java/J8.0_64/bin/java FileSystemTraversal -w /opt > opt.writeable.txt;
 /usr/lpp/java/J8.0_64/bin/java FileSystemTraversal -w /usr > usr.writeable.txt;
 /usr/lpp/java/J8.0_64/bin/java FileSystemTraversal -w /var > var.writeable.txt;
//*********************************************************************
